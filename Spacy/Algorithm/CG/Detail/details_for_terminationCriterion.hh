// This file was automatically generated by friendly type erasure.
// Please do not modify.

#pragma once

#include <functional>
#include <Spacy/Util/table_util.hh>

namespace Spacy
{
    namespace CG
    {
        namespace TerminationCriterionDetail
        {
            template < class Interface >
            struct Functions
            {
                using delete_function = void ( * )( void* );
                using clone_function = void* (*)( void* );
                using call_function = bool ( * )( const Interface&, void* );
                using clear_function = void ( * )( Interface&, void* );
                using update_function = void ( * )( Interface&, void*, double alpha, double qAq, double qPq,
                                                    double rPINVr );
                using vanishingStep_function = bool ( * )( const Interface&, void* );
                using minimalDecreaseAchieved_function = bool ( * )( const Interface&, void* );
                using setEps_function = void ( * )( Interface&, void*, double eps );
                using setAbsoluteAccuracy_function = void ( * )( Interface&, void*, double accuracy );
                using setMinimalAccuracy_function = void ( * )( Interface&, void*, double accuracy );
                using setRelativeAccuracy_function = void ( * )( Interface&, void*, double accuracy );

                delete_function del;
                clone_function clone;
                call_function call;
                clear_function clear;
                update_function update;
                vanishingStep_function vanishingStep;
                minimalDecreaseAchieved_function minimalDecreaseAchieved;
                setEps_function setEps;
                setAbsoluteAccuracy_function setAbsoluteAccuracy;
                setMinimalAccuracy_function setMinimalAccuracy;
                setRelativeAccuracy_function setRelativeAccuracy;
            };

            template < class Interface, class Impl >
            struct execution_wrapper
            {
                static bool call( const Interface& interface, void* impl )
                {
                    return static_cast< const Impl* >( impl )->operator()();
                }

                static void clear( Interface& interface, void* impl )
                {
                    static_cast< Impl* >( impl )->clear();
                }

                static void update( Interface& interface, void* impl, double alpha, double qAq, double qPq,
                                    double rPINVr )
                {
                    static_cast< Impl* >( impl )->update( std::move( alpha ), std::move( qAq ), std::move( qPq ),
                                                          std::move( rPINVr ) );
                }

                static bool vanishingStep( const Interface& interface, void* impl )
                {
                    return static_cast< const Impl* >( impl )->vanishingStep();
                }

                static bool minimalDecreaseAchieved( const Interface& interface, void* impl )
                {
                    return static_cast< const Impl* >( impl )->minimalDecreaseAchieved();
                }

                static void setEps( Interface& interface, void* impl, double eps )
                {
                    static_cast< Impl* >( impl )->setEps( std::move( eps ) );
                }

                static void setAbsoluteAccuracy( Interface& interface, void* impl, double accuracy )
                {
                    static_cast< Impl* >( impl )->setAbsoluteAccuracy( std::move( accuracy ) );
                }

                static void setMinimalAccuracy( Interface& interface, void* impl, double accuracy )
                {
                    static_cast< Impl* >( impl )->setMinimalAccuracy( std::move( accuracy ) );
                }

                static void setRelativeAccuracy( Interface& interface, void* impl, double accuracy )
                {
                    static_cast< Impl* >( impl )->setRelativeAccuracy( std::move( accuracy ) );
                }
            };

            template < class Interface, class Impl >
            struct execution_wrapper< Interface, std::reference_wrapper< Impl > >
            {
                static bool call( const Interface& interface, void* impl )
                {
                    return static_cast< std::reference_wrapper< Impl >* >( impl )->get().operator()();
                }

                static void clear( Interface& interface, void* impl )
                {
                    static_cast< std::reference_wrapper< Impl >* >( impl )->get().clear();
                }

                static void update( Interface& interface, void* impl, double alpha, double qAq, double qPq,
                                    double rPINVr )
                {
                    static_cast< std::reference_wrapper< Impl >* >( impl )->get().update(
                        std::move( alpha ), std::move( qAq ), std::move( qPq ), std::move( rPINVr ) );
                }

                static bool vanishingStep( const Interface& interface, void* impl )
                {
                    return static_cast< std::reference_wrapper< Impl >* >( impl )->get().vanishingStep();
                }

                static bool minimalDecreaseAchieved( const Interface& interface, void* impl )
                {
                    return static_cast< std::reference_wrapper< Impl >* >( impl )->get().minimalDecreaseAchieved();
                }

                static void setEps( Interface& interface, void* impl, double eps )
                {
                    static_cast< std::reference_wrapper< Impl >* >( impl )->get().setEps( std::move( eps ) );
                }

                static void setAbsoluteAccuracy( Interface& interface, void* impl, double accuracy )
                {
                    static_cast< std::reference_wrapper< Impl >* >( impl )->get().setAbsoluteAccuracy(
                        std::move( accuracy ) );
                }

                static void setMinimalAccuracy( Interface& interface, void* impl, double accuracy )
                {
                    static_cast< std::reference_wrapper< Impl >* >( impl )->get().setMinimalAccuracy(
                        std::move( accuracy ) );
                }

                static void setRelativeAccuracy( Interface& interface, void* impl, double accuracy )
                {
                    static_cast< std::reference_wrapper< Impl >* >( impl )->get().setRelativeAccuracy(
                        std::move( accuracy ) );
                }
            };

            template < class T >
            using TryMemFn_call = decltype( std::declval< T >().operator()() );
            template < class T, class = void >
            struct HasMemFn_call : std::false_type
            {
            };
            template < class T >
            struct HasMemFn_call< T, type_erasure_table_detail::voider< TryMemFn_call< T > > > : std::true_type
            {
            };
            template < class T >
            using TryMemFn_clear = decltype( std::declval< T >().clear() );
            template < class T, class = void >
            struct HasMemFn_clear : std::false_type
            {
            };
            template < class T >
            struct HasMemFn_clear< T, type_erasure_table_detail::voider< TryMemFn_clear< T > > > : std::true_type
            {
            };
            template < class T >
            using TryMemFn_update =
                decltype( std::declval< T >().update( std::declval< double >(), std::declval< double >(),
                                                      std::declval< double >(), std::declval< double >() ) );
            template < class T, class = void >
            struct HasMemFn_update : std::false_type
            {
            };
            template < class T >
            struct HasMemFn_update< T, type_erasure_table_detail::voider< TryMemFn_update< T > > > : std::true_type
            {
            };
            template < class T >
            using TryMemFn_vanishingStep = decltype( std::declval< T >().vanishingStep() );
            template < class T, class = void >
            struct HasMemFn_vanishingStep : std::false_type
            {
            };
            template < class T >
            struct HasMemFn_vanishingStep< T, type_erasure_table_detail::voider< TryMemFn_vanishingStep< T > > >
                : std::true_type
            {
            };
            template < class T >
            using TryMemFn_minimalDecreaseAchieved = decltype( std::declval< T >().minimalDecreaseAchieved() );
            template < class T, class = void >
            struct HasMemFn_minimalDecreaseAchieved : std::false_type
            {
            };
            template < class T >
            struct HasMemFn_minimalDecreaseAchieved<
                T, type_erasure_table_detail::voider< TryMemFn_minimalDecreaseAchieved< T > > > : std::true_type
            {
            };
            template < class T >
            using TryMemFn_setEps = decltype( std::declval< T >().setEps( std::declval< double >() ) );
            template < class T, class = void >
            struct HasMemFn_setEps : std::false_type
            {
            };
            template < class T >
            struct HasMemFn_setEps< T, type_erasure_table_detail::voider< TryMemFn_setEps< T > > > : std::true_type
            {
            };
            template < class T >
            using TryMemFn_setAbsoluteAccuracy =
                decltype( std::declval< T >().setAbsoluteAccuracy( std::declval< double >() ) );
            template < class T, class = void >
            struct HasMemFn_setAbsoluteAccuracy : std::false_type
            {
            };
            template < class T >
            struct HasMemFn_setAbsoluteAccuracy<
                T, type_erasure_table_detail::voider< TryMemFn_setAbsoluteAccuracy< T > > > : std::true_type
            {
            };
            template < class T >
            using TryMemFn_setMinimalAccuracy =
                decltype( std::declval< T >().setMinimalAccuracy( std::declval< double >() ) );
            template < class T, class = void >
            struct HasMemFn_setMinimalAccuracy : std::false_type
            {
            };
            template < class T >
            struct HasMemFn_setMinimalAccuracy< T,
                                                type_erasure_table_detail::voider< TryMemFn_setMinimalAccuracy< T > > >
                : std::true_type
            {
            };
            template < class T >
            using TryMemFn_setRelativeAccuracy =
                decltype( std::declval< T >().setRelativeAccuracy( std::declval< double >() ) );
            template < class T, class = void >
            struct HasMemFn_setRelativeAccuracy : std::false_type
            {
            };
            template < class T >
            struct HasMemFn_setRelativeAccuracy<
                T, type_erasure_table_detail::voider< TryMemFn_setRelativeAccuracy< T > > > : std::true_type
            {
            };

            template < class T >
            using TerminationCriterionConceptImpl = std::integral_constant<
                bool,
                HasMemFn_call< type_erasure_table_detail::remove_reference_wrapper_t< T > >::value &&
                    HasMemFn_clear< type_erasure_table_detail::remove_reference_wrapper_t< T > >::value &&
                    HasMemFn_update< type_erasure_table_detail::remove_reference_wrapper_t< T > >::value &&
                    HasMemFn_vanishingStep< type_erasure_table_detail::remove_reference_wrapper_t< T > >::value &&
                    HasMemFn_minimalDecreaseAchieved<
                        type_erasure_table_detail::remove_reference_wrapper_t< T > >::value &&
                    HasMemFn_setEps< type_erasure_table_detail::remove_reference_wrapper_t< T > >::value &&
                    HasMemFn_setAbsoluteAccuracy< type_erasure_table_detail::remove_reference_wrapper_t< T > >::value &&
                    HasMemFn_setMinimalAccuracy< type_erasure_table_detail::remove_reference_wrapper_t< T > >::value &&
                    HasMemFn_setRelativeAccuracy< type_erasure_table_detail::remove_reference_wrapper_t< T > >::value >;

            template < class Impl, class T, bool = std::is_same< Impl, T >::value >
            struct TerminationCriterionConcept : std::false_type
            {
            };
            template < class Impl, class T >
            struct TerminationCriterionConcept< Impl, T, false > : TerminationCriterionConceptImpl< T >
            {
            };
        }
    }
}
