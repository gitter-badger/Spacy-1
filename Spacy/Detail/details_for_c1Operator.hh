// This file was automatically generated by friendly type erasure.
// Please do not modify.

#pragma once

#include <memory>
#include <functional>
#include <Spacy/linearOperator.hh>
#include <Spacy/vector.hh>
#include <Spacy/vectorSpace.hh>

namespace Spacy
{
    namespace C1OperatorDetail
    {
        template < class Interface, class Buffer >
        struct Functions
        {
            using clone_function = void ( * )( void*, std::shared_ptr< void >& );
            using clone_into_function = void ( * )( void*, Buffer&, std::shared_ptr< void >& );
            using call_const_Vector__ref__function = Vector ( * )( const Interface&, void*, const Vector& x );
            using d1_function = Vector ( * )( const Interface&, void*, const Vector& x, const Vector& dx );
            using linearization_function = LinearOperator ( * )( const Interface&, void*, const Vector& x );
            using domain_function = const VectorSpace& (*)( const Interface&, void* );
            using range_function = const VectorSpace& (*)( const Interface&, void* );

            clone_function clone;
            clone_into_function clone_into;
            call_const_Vector__ref__function call_const_Vector__ref_;
            d1_function d1;
            linearization_function linearization;
            domain_function domain;
            range_function range;
        };

        template < class Interface, class Impl >
        struct execution_wrapper
        {
            static Vector call_const_Vector__ref_( const Interface& interface, void* impl, const Vector& x )
            {
                return static_cast< const Impl* >( impl )->operator()( x );
            }

            static Vector d1( const Interface& interface, void* impl, const Vector& x, const Vector& dx )
            {
                return static_cast< const Impl* >( impl )->d1( x, dx );
            }

            static LinearOperator linearization( const Interface& interface, void* impl, const Vector& x )
            {
                return static_cast< const Impl* >( impl )->linearization( x );
            }

            static const VectorSpace& domain( const Interface& interface, void* impl )
            {
                return static_cast< const Impl* >( impl )->domain();
            }

            static const VectorSpace& range( const Interface& interface, void* impl )
            {
                return static_cast< const Impl* >( impl )->range();
            }
        };

        template < class Interface, class Impl >
        struct execution_wrapper< Interface, std::reference_wrapper< Impl > >
        {
            static Vector call_const_Vector__ref_( const Interface& interface, void* impl, const Vector& x )
            {
                return static_cast< std::reference_wrapper< Impl >* >( impl )->get().operator()( x );
            }

            static Vector d1( const Interface& interface, void* impl, const Vector& x, const Vector& dx )
            {
                return static_cast< std::reference_wrapper< Impl >* >( impl )->get().d1( x, dx );
            }

            static LinearOperator linearization( const Interface& interface, void* impl, const Vector& x )
            {
                return static_cast< std::reference_wrapper< Impl >* >( impl )->get().linearization( x );
            }

            static const VectorSpace& domain( const Interface& interface, void* impl )
            {
                return static_cast< std::reference_wrapper< Impl >* >( impl )->get().domain();
            }

            static const VectorSpace& range( const Interface& interface, void* impl )
            {
                return static_cast< std::reference_wrapper< Impl >* >( impl )->get().range();
            }
        };
    }
}
