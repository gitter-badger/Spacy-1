// This file was automatically generated by friendly type erasure.
// Please do not modify.

#pragma once

#include <memory>
#include <functional>
#include <Spacy/Spaces/RealSpace/real.hh>
#include <Spacy/Util/Exceptions/incompatibleSpaceException.hh>
#include <Spacy/vectorSpace.hh>

namespace Spacy
{
    namespace ZeroVectorCreatorDetail
    {
        template < class Interface, class Buffer >
        struct Functions
        {
            using clone_function = void ( * )( void*, std::shared_ptr< void >& );
            using clone_into_function = void ( * )( void*, Buffer&, std::shared_ptr< void >& );

            clone_function clone;
            clone_into_function clone_into;
        };

        template < class Interface, class Impl >
        struct execution_wrapper
        {
        };

        template < class Interface, class Impl >
        struct execution_wrapper< Interface, std::reference_wrapper< Impl > >
        {
        };
    }

    namespace VectorDetail
    {
        template < class Interface, class Buffer >
        struct Functions
        {
            using clone_function = void ( * )( void*, std::shared_ptr< void >& );
            using clone_into_function = void ( * )( void*, Buffer&, std::shared_ptr< void >& );
            using call_const_Vector__ref__function = Real ( * )( const Interface&, void*, void* x );
            using add_const_Vector__ref__function = Interface& (*)( Interface&, void*, void* y );
            using subtract_const_Vector__ref__function = Interface& (*)( Interface&, void*, void* y );
            using multiply_double__function = Interface& (*)( Interface&, void*, double a );
            using negate_function = Interface ( * )( const Interface&, void* );
            using compare_const_Vector__ref__function = bool ( * )( const Interface&, void*, void* y );
            using space_function = const VectorSpace& (*)( const Interface&, void* );

            clone_function clone;
            clone_into_function clone_into;
            call_const_Vector__ref__function call_const_Vector__ref_;
            add_const_Vector__ref__function add_const_Vector__ref_;
            subtract_const_Vector__ref__function subtract_const_Vector__ref_;
            multiply_double__function multiply_double_;
            negate_function negate;
            compare_const_Vector__ref__function compare_const_Vector__ref_;
            space_function space;
        };

        template < class Interface, class Impl >
        struct execution_wrapper
        {
            static Real call_const_Vector__ref_( const Interface& interface, void* impl, void* x )
            {
                return static_cast< const Impl* >( impl )->operator()( *static_cast< const Impl* >( x ) );
            }

            static Interface& add_const_Vector__ref_( Interface& interface, void* impl, void* y )
            {
                static_cast< Impl* >( impl )->operator+=( *static_cast< Impl* >( y ) );
                return interface;
            }

            static Interface& subtract_const_Vector__ref_( Interface& interface, void* impl, void* y )
            {
                static_cast< Impl* >( impl )->operator-=( *static_cast< Impl* >( y ) );
                return interface;
            }

            static Interface& multiply_double_( Interface& interface, void* impl, double a )
            {
                static_cast< Impl* >( impl )->operator*=( std::move( a ) );
                return interface;
            }

            static Interface negate( const Interface& interface, void* impl )
            {
                return static_cast< const Impl* >( impl )->operator-();
            }

            static bool compare_const_Vector__ref_( const Interface& interface, void* impl, void* y )
            {
                return static_cast< const Impl* >( impl )->operator==( *static_cast< const Impl* >( y ) );
            }

            static const VectorSpace& space( const Interface& interface, void* impl )
            {
                return static_cast< const Impl* >( impl )->space();
            }
        };

        template < class Interface, class Impl >
        struct execution_wrapper< Interface, std::reference_wrapper< Impl > >
        {
            static Real call_const_Vector__ref_( const Interface& interface, void* impl, void* x )
            {
                return static_cast< std::reference_wrapper< Impl >* >( impl )->get().operator()(
                    static_cast< std::reference_wrapper< Impl >* >( x )->get() );
            }

            static Interface& add_const_Vector__ref_( Interface& interface, void* impl, void* y )
            {
                static_cast< std::reference_wrapper< Impl >* >( impl )->get().operator+=(
                    static_cast< std::reference_wrapper< Impl >* >( y )->get() );
                return interface;
            }

            static Interface& subtract_const_Vector__ref_( Interface& interface, void* impl, void* y )
            {
                static_cast< std::reference_wrapper< Impl >* >( impl )->get().operator-=(
                    static_cast< std::reference_wrapper< Impl >* >( y )->get() );
                return interface;
            }

            static Interface& multiply_double_( Interface& interface, void* impl, double a )
            {
                static_cast< std::reference_wrapper< Impl >* >( impl )->get().operator*=( std::move( a ) );
                return interface;
            }

            static Interface negate( const Interface& interface, void* impl )
            {
                return static_cast< std::reference_wrapper< Impl >* >( impl )->get().operator-();
            }

            static bool compare_const_Vector__ref_( const Interface& interface, void* impl, void* y )
            {
                return static_cast< std::reference_wrapper< Impl >* >( impl )->get().operator==(
                    static_cast< std::reference_wrapper< Impl >* >( y )->get() );
            }

            static const VectorSpace& space( const Interface& interface, void* impl )
            {
                return static_cast< std::reference_wrapper< Impl >* >( impl )->get().space();
            }
        };
    }
}
