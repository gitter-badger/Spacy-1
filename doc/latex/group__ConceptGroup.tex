\hypertarget{group__ConceptGroup}{}\section{Concepts}
\label{group__ConceptGroup}\index{Concepts@{Concepts}}


Concepts for vectors, functional, operators, ...  


Collaboration diagram for Concepts\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=293pt]{group__ConceptGroup}
\end{center}
\end{figure}
\subsection*{Modules}
\begin{DoxyCompactItemize}
\item 
\hyperlink{group__NewtonConceptGroup}{Concepts for Newton\textquotesingle{}s method}
\begin{DoxyCompactList}\small\item\em Concepts for damping strategy and termination criteria for Newton\textquotesingle{}s method. \end{DoxyCompactList}\item 
\hyperlink{group__CGConceptGroup}{Concepts for conjugate gradient methods}
\begin{DoxyCompactList}\small\item\em Concept for termination criteria for conjugate gradient methods. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{group__ConceptGroup_ga63426675cc05ccce03ead56a4fa90d96_ga63426675cc05ccce03ead56a4fa90d96}{Spacy\+::\+Concepts\+::\+Concept\+Base} = boost\+::mpl\+::vector$<$ boost\+::type\+\_\+erasure\+::copy\+\_\+constructible$<$$>$, boost\+::type\+\_\+erasure\+::typeid\+\_\+$<$$>$, boost\+::type\+\_\+erasure\+::relaxed $>$
\begin{DoxyCompactList}\small\item\em Base concept. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga30692db093ead5a1a074905363a2f043_ga30692db093ead5a1a074905363a2f043}{Spacy\+::\+Concepts\+::\+Dynamic\+Callable\+Operator\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ Vector(double t, const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept defining the simplest possible time-\/dependent operator, only providing \hyperlink{classSpacy_1_1Vector}{Vector} operator()(double t, const Vector\&). \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga2c979d268f0ca7a436776a9631d10af7_ga2c979d268f0ca7a436776a9631d10af7}{Spacy\+::\+Concepts\+::\+Dynamic\+Operator\+Concept} = boost\+::mpl\+::vector$<$ Dynamic\+Callable\+Operator\+Concept, has\+\_\+\+M$<$ boost\+::type\+\_\+erasure\+::any$<$ Linear\+Operator\+Concept $>$(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+domain$<$ const Vector\+Space \&(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+range$<$ const Vector\+Space \&(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept defining general time-\/dependent operators. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga015b0d099011a2ef73a16aa9b36a7346_ga015b0d099011a2ef73a16aa9b36a7346}{Spacy\+::\+Concepts\+::\+Dynamic\+Linear\+Operator\+Concept} = boost\+::mpl\+::vector$<$ Dynamic\+Operator\+Concept, has\+\_\+solver$<$ const boost\+::type\+\_\+erasure\+::any$<$ Linear\+Solver\+Concept $>$ \&(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept defining time-\/dependent linear operators. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_gaa7ef0ce2d66b0610035541b580564b11_gaa7ef0ce2d66b0610035541b580564b11}{Spacy\+::\+Concepts\+::\+Dynamic\+C1\+Operator\+Concept} = boost\+::mpl\+::vector$<$ Dynamic\+Operator\+Concept, has\+\_\+d1$<$ Vector(double t, const Vector \&, const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+linearization$<$ boost\+::type\+\_\+erasure\+::any$<$ Linear\+Operator\+Concept $>$(double t, const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept defining time-\/dependent operators that are differentiable with respect to the spatial variable. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga6b5c97b0e58318ef98c43a9b8a7dae08_ga6b5c97b0e58318ef98c43a9b8a7dae08}{Spacy\+::\+Concepts\+::\+My\+Error\+Estimator\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ double(const Vector \&, const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+refine$<$ void()$>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for time integrators. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga5273b50bd3e8c9a3f5a1e6b5f170836d_ga5273b50bd3e8c9a3f5a1e6b5f170836d}{Spacy\+::\+Concepts\+::\+Functional\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ Real(const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+domain$<$ const Vector\+Space \&(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for functionals. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga205b55d8291e0f2e143f116cf78bc54f_ga205b55d8291e0f2e143f116cf78bc54f}{Spacy\+::\+Concepts\+::\+C1\+Functional\+Concept} = boost\+::mpl\+::vector$<$ Functional\+Concept, has\+\_\+d1\+\_\+dual$<$ Vector(const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for differentiable functionals. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_gafb4414561b07b27100cad81ecf152e47_gafb4414561b07b27100cad81ecf152e47}{Spacy\+::\+Concepts\+::\+C2\+Functional\+Concept} = boost\+::mpl\+::vector$<$ C1\+Functional\+Concept, has\+\_\+d2\+\_\+dual$<$ Vector(const Vector \&, const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+hessian$<$ boost\+::type\+\_\+erasure\+::any$<$ Linear\+Operator\+Concept $>$(const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for twice differentiable functionals. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_gac7d6a94c7131c8613e2ab26fddeb50bd_gac7d6a94c7131c8613e2ab26fddeb50bd}{Spacy\+::\+Concepts\+::\+Linear\+Solver\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ Vector(const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for linear solver implementations. Same as \hyperlink{group__ConceptGroup_gadec0c664abaacc2065dadd8b11cc8d30_CallableOperatorConceptAnchor}{Callable\+Operator\+Concept}. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga582dd34334cdecc7b27883f4e8239490_ga582dd34334cdecc7b27883f4e8239490}{Spacy\+::\+Concepts\+::\+Indefinite\+Linear\+Solver\+Concept} = boost\+::mpl\+::vector$<$ Linear\+Solver\+Concept, has\+\_\+is\+Positive\+Definite$<$ bool(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for linear solver implementations that monitor positive definiteness. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga8b6032c46f6e31840a2c956c6360549b_ga8b6032c46f6e31840a2c956c6360549b}{Spacy\+::\+Concepts\+::\+Norm\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ Real(const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for norm implementations. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_gadec0c664abaacc2065dadd8b11cc8d30_gadec0c664abaacc2065dadd8b11cc8d30}{Spacy\+::\+Concepts\+::\+Callable\+Operator\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ Vector(const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept defining the simplest possible operator, only providing \hyperlink{classSpacy_1_1Vector}{Vector} operator()(const Vector\&). \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga7d984281b647a6d8e4c0a7ea5faeb90e_ga7d984281b647a6d8e4c0a7ea5faeb90e}{Spacy\+::\+Concepts\+::\+Operator\+Concept} = boost\+::mpl\+::vector$<$ Callable\+Operator\+Concept, has\+\_\+domain$<$ const Vector\+Space \&(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+range$<$ const Vector\+Space \&(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept defining general operators. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_gaf0e18e41c434cfceb77ccb8e785a8055_gaf0e18e41c434cfceb77ccb8e785a8055}{Spacy\+::\+Concepts\+::\+Linear\+Operator\+Concept} = boost\+::mpl\+::vector$<$ Operator\+Concept, Vector\+Concept, has\+\_\+solver$<$ boost\+::type\+\_\+erasure\+::any$<$ Linear\+Solver\+Concept $>$(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept defining linear operators. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga14a12c741dc237e32862fa4bc315451b_ga14a12c741dc237e32862fa4bc315451b}{Spacy\+::\+Concepts\+::\+C1\+Operator\+Concept} = boost\+::mpl\+::vector$<$ Operator\+Concept, has\+\_\+d1$<$ Vector(const Vector \&, const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+linearization$<$ boost\+::type\+\_\+erasure\+::any$<$ Linear\+Operator\+Concept $>$(const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept defining differentiable operators. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga1308724cda3078f228fb05c29556805d_ga1308724cda3078f228fb05c29556805d}{Spacy\+::\+Concepts\+::\+Scalar\+Product\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ Real(const Vector \&, const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for scalar products. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga45ecfe57ffb996aa97c9ff89a647f095_ga45ecfe57ffb996aa97c9ff89a647f095}{Spacy\+::\+Concepts\+::\+Time\+Integrator\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ Vector(double, const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+set\+Time\+Step$<$ void(double)$>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for time integrators. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_gad6958389d1fa2758a8a64a0a24c36004_gad6958389d1fa2758a8a64a0a24c36004}{Spacy\+::\+Concepts\+::\+Vector\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::assignable$<$$>$, boost\+::type\+\_\+erasure\+::multiply\+\_\+assignable$<$ boost\+::type\+\_\+erasure\+::\+\_\+self, double $>$, boost\+::type\+\_\+erasure\+::add\+\_\+assignable$<$$>$, boost\+::type\+\_\+erasure\+::subtract\+\_\+assignable$<$$>$, boost\+::type\+\_\+erasure\+::negatable$<$$>$, boost\+::type\+\_\+erasure\+::equality\+\_\+comparable$<$$>$, boost\+::type\+\_\+erasure\+::callable$<$ Vector(const boost\+::type\+\_\+erasure\+::\+\_\+self \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+space$<$ const Vector\+Space $\ast$(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+to\+File$<$ void(const std\+::string \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for vector implementations. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga3064301642b7c66b1b08f88a12a04645_ga3064301642b7c66b1b08f88a12a04645}{Spacy\+::\+Concepts\+::\+Vector\+Creator\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ boost\+::type\+\_\+erasure\+::any$<$ Vector\+Concept $>$(const Vector\+Space $\ast$), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em \hyperlink{classSpacy_1_1Vector}{Vector} creator concept. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Concepts for vectors, functional, operators, ... 

The concepts are employed with Boost.\+Type\+Erasure, i.\+e. Vector\+Concept yields the type boost\+::type\+\_\+erasure\+::any$<$\+Vector\+Concept$>$. 

\subsection{Typedef Documentation}
\hypertarget{group__ConceptGroup_ga205b55d8291e0f2e143f116cf78bc54f_ga205b55d8291e0f2e143f116cf78bc54f}{}\index{Concepts@{Concepts}!C1\+Functional\+Concept@{C1\+Functional\+Concept}}
\index{C1\+Functional\+Concept@{C1\+Functional\+Concept}!Concepts@{Concepts}}
\subsubsection[{C1\+Functional\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+C1\+Functional\+Concept} = typedef boost\+::mpl\+::vector$<$ Functional\+Concept , has\+\_\+d1\+\_\+dual$<$Vector(const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga205b55d8291e0f2e143f116cf78bc54f_ga205b55d8291e0f2e143f116cf78bc54f}


Concept for differentiable functionals. 

\label{group__ConceptGroup_ga205b55d8291e0f2e143f116cf78bc54f_C1FunctionalConceptAnchor}%
\hypertarget{group__ConceptGroup_ga205b55d8291e0f2e143f116cf78bc54f_C1FunctionalConceptAnchor}{}%
The minimal signature of a differentiable functional is 
\begin{DoxyCode}
1 // A differentiable functional f: X->R.
2 class MyC1Functional
3 \{
4 public:
5   // Copy constructor, possibly default-generated.
6   MyC1Functional(const MyC1Functional&);
7 
8   // Move constructor, possibly default-generated.
9   MyC1Functional(MyC1Functional&&);
10 
11   // Compute f(x).
12   double operator()(const ::Spacy::Vector& x) const;
13 
14   // Compute f'(x) as element of X*.
15   ::Spacy::Vector d1(const ::Spacy::Vector& x) const;
16 
17   // Access underlying domain.
18   const VectorSpace& domain() const;
19 \};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_gaa7cb8ef6c287b0af0352d3dd0eb9f200_C1FunctionalAnchor}{\+:\+:Spacy\+:\+:C1\+Functional}. \hypertarget{group__ConceptGroup_ga14a12c741dc237e32862fa4bc315451b_ga14a12c741dc237e32862fa4bc315451b}{}\index{Concepts@{Concepts}!C1\+Operator\+Concept@{C1\+Operator\+Concept}}
\index{C1\+Operator\+Concept@{C1\+Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{C1\+Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+C1\+Operator\+Concept} = typedef boost\+::mpl\+::vector$<$ Operator\+Concept , has\+\_\+d1$<$Vector(const Vector\&,const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+linearization$<$boost\+::type\+\_\+erasure\+::any$<$Linear\+Operator\+Concept$>$(const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga14a12c741dc237e32862fa4bc315451b_ga14a12c741dc237e32862fa4bc315451b}


Concept defining differentiable operators. 

\label{group__ConceptGroup_ga14a12c741dc237e32862fa4bc315451b_C1OperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_ga14a12c741dc237e32862fa4bc315451b_C1OperatorConceptAnchor}{}%
The minimal signature for a differentiable operator is\+: 
\begin{DoxyCode}
1 // My differentiable operator A: X->Y.
2 class MyOperator
3 \{
4 public:
5   // Copy constructor.
6   MyOperator(const MyOperator&);
7 
8   // Move constructor.
9   MyOperator(MyOperator&&);
10 
11   // Compute A(x).
12   ::Spacy::Vector operator()(const ::Spacy::Vector& x) const;
13 
14   // Compute A'(x)dx.
15   ::Spacy::Vector d1(const ::Spacy::Vector& x, const ::Spacy::Vector& dx) const;
16 
17   // Get linearization representing A'(x).
18  ::Spacy::LinearOperator linearization(const ::Spacy::Vector& x) const;
19 
20   // Access domain space.
21   const VectorSpace& domain() const;
22 
23   // Access range space.
24   const VectorSpace& range() const;
25 \};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_ga87ae8cb0d7a567a4bb181e0a9f182620_C1OperatorAnchor}{\+:\+:Spacy\+:\+:C1\+Operator}. \hypertarget{group__ConceptGroup_gafb4414561b07b27100cad81ecf152e47_gafb4414561b07b27100cad81ecf152e47}{}\index{Concepts@{Concepts}!C2\+Functional\+Concept@{C2\+Functional\+Concept}}
\index{C2\+Functional\+Concept@{C2\+Functional\+Concept}!Concepts@{Concepts}}
\subsubsection[{C2\+Functional\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+C2\+Functional\+Concept} = typedef boost\+::mpl\+::vector$<$ C1\+Functional\+Concept , has\+\_\+d2\+\_\+dual$<$Vector(const Vector\&,const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+hessian$<$boost\+::type\+\_\+erasure\+::any$<$Linear\+Operator\+Concept$>$(const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_gafb4414561b07b27100cad81ecf152e47_gafb4414561b07b27100cad81ecf152e47}


Concept for twice differentiable functionals. 

\label{group__ConceptGroup_gafb4414561b07b27100cad81ecf152e47_C2FunctionalConceptAnchor}%
\hypertarget{group__ConceptGroup_gafb4414561b07b27100cad81ecf152e47_C2FunctionalConceptAnchor}{}%
The minimal signature of a twice differentiable functional is 
\begin{DoxyCode}
1 // A twice differentiable functional f: X->R.
2 class MyC2Functional
3 \{
4 public:
5   // Copy constructor, possibly default-generated.
6   MyC2Functional(const MyC2Functional&);
7 
8   // Move constructor, possibly default-generated.
9   MyC2Functional(MyC2Functional&&);
10 
11   // Compute f(x).
12   double operator()(const ::Spacy::Vector& x) const;
13 
14   // Compute f'(x) as element of X*.
15   ::Spacy::Vector d1(const ::Spacy::Vector& x) const;
16 
17   // Compute f''(x)dx as element of X*.
18   ::Spacy::Vector d2(const ::Spacy::Vector& x, const ::Spacy::Vector& dx) const;
19 
20   // Access f''(x) as mapping f''(x): X->X*.
21   LinearOperator hessian(const ::Spacy::Vector& x);
22 
23   // Access underlying domain.
24   const VectorSpace& domain() const;
25 \};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_gaf5b89e117806134b06a1ce4629fb2b65_C2FunctionalAnchor}{\+:\+:Spacy\+:\+:C2\+Functional}. \hypertarget{group__ConceptGroup_gadec0c664abaacc2065dadd8b11cc8d30_gadec0c664abaacc2065dadd8b11cc8d30}{}\index{Concepts@{Concepts}!Callable\+Operator\+Concept@{Callable\+Operator\+Concept}}
\index{Callable\+Operator\+Concept@{Callable\+Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Callable\+Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Callable\+Operator\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::callable$<$Vector(const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_gadec0c664abaacc2065dadd8b11cc8d30_gadec0c664abaacc2065dadd8b11cc8d30}


Concept defining the simplest possible operator, only providing \hyperlink{classSpacy_1_1Vector}{Vector} operator()(const Vector\&). 

\label{group__ConceptGroup_gadec0c664abaacc2065dadd8b11cc8d30_CallableOperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_gadec0c664abaacc2065dadd8b11cc8d30_CallableOperatorConceptAnchor}{}%
The minimal signature of a callable operator is\+: 
\begin{DoxyCode}
1 // My callable operator A: X->Y.
2 class MyOperator
3 \{
4 public:
5   // Copy constructor.
6   MyOperator(const MyOperator&);
7 
8   // Move constructor.
9   MyOperator(MyOperator&&);
10 
11   // Compute A(x).
12   ::Spacy::Vector operator()(const ::Spacy::Vector& x) const;
13 \};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_ga2b74020d806ad800795cdd97dab3466f_CallableOperatorAnchor}{\+:\+:Spacy\+:\+:Callable\+Operator}. \hypertarget{group__ConceptGroup_ga63426675cc05ccce03ead56a4fa90d96_ga63426675cc05ccce03ead56a4fa90d96}{}\index{Concepts@{Concepts}!Concept\+Base@{Concept\+Base}}
\index{Concept\+Base@{Concept\+Base}!Concepts@{Concepts}}
\subsubsection[{Concept\+Base}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Concept\+Base} = typedef boost\+::mpl\+::vector$<$ boost\+::type\+\_\+erasure\+::copy\+\_\+constructible$<$$>$ , boost\+::type\+\_\+erasure\+::typeid\+\_\+$<$$>$ , boost\+::type\+\_\+erasure\+::relaxed $>$}\label{group__ConceptGroup_ga63426675cc05ccce03ead56a4fa90d96_ga63426675cc05ccce03ead56a4fa90d96}


Base concept. 

Requires copy-\/constructability, provides run-\/time type information and some convenience functions with boost\+::type\+\_\+erasure\+::relaxed. \hypertarget{group__ConceptGroup_gaa7ef0ce2d66b0610035541b580564b11_gaa7ef0ce2d66b0610035541b580564b11}{}\index{Concepts@{Concepts}!Dynamic\+C1\+Operator\+Concept@{Dynamic\+C1\+Operator\+Concept}}
\index{Dynamic\+C1\+Operator\+Concept@{Dynamic\+C1\+Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Dynamic\+C1\+Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Dynamic\+C1\+Operator\+Concept} = typedef boost\+::mpl\+::vector$<$ Dynamic\+Operator\+Concept , has\+\_\+d1$<$Vector(double t, const Vector\&,const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+linearization$<$boost\+::type\+\_\+erasure\+::any$<$Linear\+Operator\+Concept$>$(double t, const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_gaa7ef0ce2d66b0610035541b580564b11_gaa7ef0ce2d66b0610035541b580564b11}


Concept defining time-\/dependent operators that are differentiable with respect to the spatial variable. 

\label{group__ConceptGroup_gaa7ef0ce2d66b0610035541b580564b11_DynamicC1OperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_gaa7ef0ce2d66b0610035541b580564b11_DynamicC1OperatorConceptAnchor}{}%
The minimal signature for a time-\/dependent differentiable operator is\+: 
\begin{DoxyCode}
1 // My differentiable operator A: [0,T[ \(\backslash\)times X -> Y.
2 class MyOperator
3 \{
4 public:
5   // Copy constructor.
6   MyOperator(const MyOperator&);
7 
8   // Move constructor.
9   MyOperator(MyOperator&&);
10 
11   // Compute A(t,x).
12   ::Spacy::Vector operator()(double t, const ::Spacy::Vector& x) const;
13 
14   // Compute A\_x(t,x)dx.
15   ::Spacy::Vector d1(double t, const ::Spacy::Vector& x, const ::Spacy::Vector& dx) const;
16 
17   // Get linearization representing A\_x(t,x).
18  ::Spacy::LinearOperator linearization(double t, const ::Spacy::Vector& x) const;
19 
20   // Access mass matrix.
21   LinearOperator M() const;
22 
23   // Access domain space.
24   const VectorSpace& domain() const;
25 
26   // Access range space.
27   const VectorSpace& range() const;
28 \};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_gabc9c830d2a7e020bcab097b10ee6f642_DynamicC1OperatorAnchor}{\+:\+:Spacy\+:\+:Dynamic\+C1\+Operator}. \hypertarget{group__ConceptGroup_ga30692db093ead5a1a074905363a2f043_ga30692db093ead5a1a074905363a2f043}{}\index{Concepts@{Concepts}!Dynamic\+Callable\+Operator\+Concept@{Dynamic\+Callable\+Operator\+Concept}}
\index{Dynamic\+Callable\+Operator\+Concept@{Dynamic\+Callable\+Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Dynamic\+Callable\+Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Dynamic\+Callable\+Operator\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::callable$<$Vector(double t, const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga30692db093ead5a1a074905363a2f043_ga30692db093ead5a1a074905363a2f043}


Concept defining the simplest possible time-\/dependent operator, only providing \hyperlink{classSpacy_1_1Vector}{Vector} operator()(double t, const Vector\&). 

\label{group__ConceptGroup_ga30692db093ead5a1a074905363a2f043_DynamicCallableOperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_ga30692db093ead5a1a074905363a2f043_DynamicCallableOperatorConceptAnchor}{}%
The minimal signature of a time-\/dependent callable operator is\+: 
\begin{DoxyCode}
1 // My callable operator A: [0,T[ \(\backslash\)times X -> Y.
2 class MyOperator
3 \{
4 public:
5   // Copy constructor.
6   MyOperator(const MyOperator&);
7 
8   // Move constructor.
9   MyOperator(MyOperator&&);
10 
11   // Compute A(t,x).
12   ::Spacy::Vector operator()(double t, const ::Spacy::Vector& x) const;
13 \};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_ga750d55072f7a3a16a1263961147333c0_DynamicCallableOperatorAnchor}{\+:\+:Spacy\+:\+:Dynamic\+Callable\+Operator}. \hypertarget{group__ConceptGroup_ga015b0d099011a2ef73a16aa9b36a7346_ga015b0d099011a2ef73a16aa9b36a7346}{}\index{Concepts@{Concepts}!Dynamic\+Linear\+Operator\+Concept@{Dynamic\+Linear\+Operator\+Concept}}
\index{Dynamic\+Linear\+Operator\+Concept@{Dynamic\+Linear\+Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Dynamic\+Linear\+Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Dynamic\+Linear\+Operator\+Concept} = typedef boost\+::mpl\+::vector$<$ Dynamic\+Operator\+Concept , has\+\_\+solver$<$const boost\+::type\+\_\+erasure\+::any$<$Linear\+Solver\+Concept$>$\&(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga015b0d099011a2ef73a16aa9b36a7346_ga015b0d099011a2ef73a16aa9b36a7346}


Concept defining time-\/dependent linear operators. 

\label{group__ConceptGroup_ga015b0d099011a2ef73a16aa9b36a7346_DynamicLinearOperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_ga015b0d099011a2ef73a16aa9b36a7346_DynamicLinearOperatorConceptAnchor}{}%
The minimal signature of a time-\/dependent linear operator is\+: 
\begin{DoxyCode}
1 // My linear operator A: [0,T[ \(\backslash\)times X -> Y.
2 class MyLinearOperator
3 \{
4 public:
5   // Copy constructor.
6   MyLinearOperator(const MyLinearOperator&);
7 
8   // Move constructor.
9   MyLinearOperator(MyLinearOperator&&);
10 
11   // Compute A(t,x).
12   ::Spacy::Vector operator()(double t, const ::Spacy::Vector& x) const;
13 
14   // Access solver for the computation of A(t)^-1.
15   ::Spacy::LinearSolver solver() const;
16 
17   // Access domain space.
18   const VectorSpace& domain() const;
19 
20   // Access range space.
21   const VectorSpace& range() const;
22 \};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_gaad10aa7d5443703377b768fa41a3c7ea_DynamicLinearOperatorAnchor}{\+:\+:Spacy\+:\+:Dynamic\+Linear\+Operator}. \hypertarget{group__ConceptGroup_ga2c979d268f0ca7a436776a9631d10af7_ga2c979d268f0ca7a436776a9631d10af7}{}\index{Concepts@{Concepts}!Dynamic\+Operator\+Concept@{Dynamic\+Operator\+Concept}}
\index{Dynamic\+Operator\+Concept@{Dynamic\+Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Dynamic\+Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Dynamic\+Operator\+Concept} = typedef boost\+::mpl\+::vector$<$ Dynamic\+Callable\+Operator\+Concept , has\+\_\+\+M$<$boost\+::type\+\_\+erasure\+::any$<$ Linear\+Operator\+Concept $>$(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+domain$<$const Vector\+Space\&(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+range$<$const Vector\+Space\&(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga2c979d268f0ca7a436776a9631d10af7_ga2c979d268f0ca7a436776a9631d10af7}


Concept defining general time-\/dependent operators. 

\label{group__ConceptGroup_ga2c979d268f0ca7a436776a9631d10af7_DynamicOperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_ga2c979d268f0ca7a436776a9631d10af7_DynamicOperatorConceptAnchor}{}%
The minimal signature of a time-\/dependent operator is\+: 
\begin{DoxyCode}
1 // My operator A: [0,T[ \(\backslash\)times X -> Y.
2 class MyOperator
3 \{
4 public:
5   // Copy constructor.
6   MyOperator(const MyOperator&);
7 
8   // Move constructor.
9   MyOperator(MyOperator&&);
10 
11   // Compute A(t,x).
12   ::Spacy::Vector operator()(double t, const ::Spacy::Vector& x) const;
13 
14   // Access domain space.
15   const VectorSpace& domain() const;
16 
17   // Access mass matrix.
18   LinearOperator M() const;
19 
20   // Access range space.
21   const VectorSpace& range() const;
22 \};
\end{DoxyCode}


See \+:\+:Spacy\+:\+:Dynamic\+Operator. \hypertarget{group__ConceptGroup_ga5273b50bd3e8c9a3f5a1e6b5f170836d_ga5273b50bd3e8c9a3f5a1e6b5f170836d}{}\index{Concepts@{Concepts}!Functional\+Concept@{Functional\+Concept}}
\index{Functional\+Concept@{Functional\+Concept}!Concepts@{Concepts}}
\subsubsection[{Functional\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Functional\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$Real(const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$, has\+\_\+domain$<$const Vector\+Space\&(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga5273b50bd3e8c9a3f5a1e6b5f170836d_ga5273b50bd3e8c9a3f5a1e6b5f170836d}


Concept for functionals. 

\label{group__ConceptGroup_ga5273b50bd3e8c9a3f5a1e6b5f170836d_FunctionalConceptAnchor}%
\hypertarget{group__ConceptGroup_ga5273b50bd3e8c9a3f5a1e6b5f170836d_FunctionalConceptAnchor}{}%
The minimal signature of a functional is\+: 
\begin{DoxyCode}
1 // A functional f: X->R.
2 class MyFunctional
3 \{
4 public:
5   // Compute f(x).
6   double operator()(const ::Spacy::Vector& x) const;
7 
8   // Access underlying domain.
9   const VectorSpace& domain() const;
10 \};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_ga673218f603c93790864aef12c89d3a35_FunctionalAnchor}{\+:\+:Spacy\+:\+:Functional}. \hypertarget{group__ConceptGroup_ga582dd34334cdecc7b27883f4e8239490_ga582dd34334cdecc7b27883f4e8239490}{}\index{Concepts@{Concepts}!Indefinite\+Linear\+Solver\+Concept@{Indefinite\+Linear\+Solver\+Concept}}
\index{Indefinite\+Linear\+Solver\+Concept@{Indefinite\+Linear\+Solver\+Concept}!Concepts@{Concepts}}
\subsubsection[{Indefinite\+Linear\+Solver\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Indefinite\+Linear\+Solver\+Concept} = typedef boost\+::mpl\+::vector$<$ Linear\+Solver\+Concept , has\+\_\+is\+Positive\+Definite$<$bool(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga582dd34334cdecc7b27883f4e8239490_ga582dd34334cdecc7b27883f4e8239490}


Concept for linear solver implementations that monitor positive definiteness. 

\label{group__ConceptGroup_ga582dd34334cdecc7b27883f4e8239490_IndefiniteLinearSolverConceptAnchor}%
\hypertarget{group__ConceptGroup_ga582dd34334cdecc7b27883f4e8239490_IndefiniteLinearSolverConceptAnchor}{}%
The minimal signature of a general linear solver is\+: 
\begin{DoxyCode}
1 // My general linear solver S representing A^-1.
2 class MyIndefiniteLinearSolver
3 \{
4 public:
5   // Copy constructor.
6   MyIndefiniteLinearSolver(const MyIndefiniteLinearSolver&);
7 
8   // Move constructor.
9   MyIndefiniteLinearSolver(MyIndefiniteLinearSolver&&);
10 
11   // Compute A^-1(x).
12   ::Spacy::Vector operator()(const ::Spacy::Vector& x) const;
13 
14   // Check if A is positive definite
15   bool isPositiveDefinite() const;
16 \};
\end{DoxyCode}


See \hyperlink{namespaceSpacy_a168383be933a8316169c145f5e419604_IndefiniteLinearSolverAnchor}{\+:\+:Spacy\+:\+:Indefinite\+Linear\+Solver}. \hypertarget{group__ConceptGroup_gaf0e18e41c434cfceb77ccb8e785a8055_gaf0e18e41c434cfceb77ccb8e785a8055}{}\index{Concepts@{Concepts}!Linear\+Operator\+Concept@{Linear\+Operator\+Concept}}
\index{Linear\+Operator\+Concept@{Linear\+Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Linear\+Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Linear\+Operator\+Concept} = typedef boost\+::mpl\+::vector$<$ Operator\+Concept , Vector\+Concept , has\+\_\+solver$<$boost\+::type\+\_\+erasure\+::any$<$Linear\+Solver\+Concept$>$(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_gaf0e18e41c434cfceb77ccb8e785a8055_gaf0e18e41c434cfceb77ccb8e785a8055}


Concept defining linear operators. 

\label{group__ConceptGroup_gaf0e18e41c434cfceb77ccb8e785a8055_LinearOperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_gaf0e18e41c434cfceb77ccb8e785a8055_LinearOperatorConceptAnchor}{}%
The minimal signature of a linear operator is\+: 
\begin{DoxyCode}
1 // My linear operator A: X->Y.
2 class MyLinearOperator
3 \{
4 public:
5   // Copy constructor.
6   MyLinearOperator(const MyLinearOperator&);
7 
8   // Move constructor.
9   MyLinearOperator(MyLinearOperator&&);
10 
11   // Compute A(x).
12   ::Spacy::Vector operator()(const ::Spacy::Vector& x) const;
13 
14   // Access solver for the computation of A^-1.
15   ::Spacy::LinearSolver solver() const;
16 
17   // Access domain space.
18   const VectorSpace& domain() const;
19 
20   // Access range space.
21   const VectorSpace& range() const;
22 \};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_ga584f7b9d82a844302ba0d77c3a1b6640_LinearOperatorAnchor}{\+:\+:Spacy\+:\+:Linear\+Operator}. \hypertarget{group__ConceptGroup_gac7d6a94c7131c8613e2ab26fddeb50bd_gac7d6a94c7131c8613e2ab26fddeb50bd}{}\index{Concepts@{Concepts}!Linear\+Solver\+Concept@{Linear\+Solver\+Concept}}
\index{Linear\+Solver\+Concept@{Linear\+Solver\+Concept}!Concepts@{Concepts}}
\subsubsection[{Linear\+Solver\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Linear\+Solver\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::callable$<$Vector(const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_gac7d6a94c7131c8613e2ab26fddeb50bd_gac7d6a94c7131c8613e2ab26fddeb50bd}


Concept for linear solver implementations. Same as \hyperlink{group__ConceptGroup_gadec0c664abaacc2065dadd8b11cc8d30_CallableOperatorConceptAnchor}{Callable\+Operator\+Concept}. 

\label{group__ConceptGroup_gac7d6a94c7131c8613e2ab26fddeb50bd_LinearSolverConceptAnchor}%
\hypertarget{group__ConceptGroup_gac7d6a94c7131c8613e2ab26fddeb50bd_LinearSolverConceptAnchor}{}%
The minimal signature of a linear solver is\+: 
\begin{DoxyCode}
1 // My linear solver representing A^-1.
2 class MyLinearSolver
3 \{
4 public:
5   // Copy constructor.
6   MyLinearSolver(const MyLinearSolver&);
7 
8   // Move constructor.
9   MyLinearSolver(MyLinearSolver&&);
10 
11   // Compute A^-1(x).
12   ::Spacy::Vector operator()(const ::Spacy::Vector& x) const;
13 \};
\end{DoxyCode}


See \hyperlink{namespaceSpacy_a7d5cd1c6fb9dd85aa345b536caf30bba_LinearSolverAnchor}{\+:\+:Spacy\+:\+:Linear\+Solver}, \hyperlink{group__ConceptGroup_gadec0c664abaacc2065dadd8b11cc8d30_CallableOperatorConceptAnchor}{Callable\+Operator\+Concept} \hypertarget{group__ConceptGroup_ga6b5c97b0e58318ef98c43a9b8a7dae08_ga6b5c97b0e58318ef98c43a9b8a7dae08}{}\index{Concepts@{Concepts}!My\+Error\+Estimator\+Concept@{My\+Error\+Estimator\+Concept}}
\index{My\+Error\+Estimator\+Concept@{My\+Error\+Estimator\+Concept}!Concepts@{Concepts}}
\subsubsection[{My\+Error\+Estimator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+My\+Error\+Estimator\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::callable$<$double(const Vector\&, const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+refine$<$void()$>$ $>$}\label{group__ConceptGroup_ga6b5c97b0e58318ef98c43a9b8a7dae08_ga6b5c97b0e58318ef98c43a9b8a7dae08}


Concept for time integrators. 

\label{group__ConceptGroup_ga6b5c97b0e58318ef98c43a9b8a7dae08_ErrorEstimatorConceptAnchor}%
\hypertarget{group__ConceptGroup_ga6b5c97b0e58318ef98c43a9b8a7dae08_ErrorEstimatorConceptAnchor}{}%
The minimal signature of an error estimator is\+: 
\begin{DoxyCode}
1 // My error estimator.
2 class MyErrorEstimator
3 \{
4 public:
5   // Copy constructor.
6   MyErrorEstimator(const MyErrorEstimator&);
7 
8   // Move constructor.
9   MyErrorEstimator(MyErrorEstimator&&);
10 
11   // Compute error estimate.
12   double operator()(const ::Spacy::Vector& x, const ::Spacy::Vector& dx) const;
13 
14   // Refine grid.
15   void refine();
16 \};
\end{DoxyCode}


See \+:\+:Spacy\+:\+:My\+Error\+Estimator. \hypertarget{group__ConceptGroup_ga8b6032c46f6e31840a2c956c6360549b_ga8b6032c46f6e31840a2c956c6360549b}{}\index{Concepts@{Concepts}!Norm\+Concept@{Norm\+Concept}}
\index{Norm\+Concept@{Norm\+Concept}!Concepts@{Concepts}}
\subsubsection[{Norm\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Norm\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::callable$<$Real(const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga8b6032c46f6e31840a2c956c6360549b_ga8b6032c46f6e31840a2c956c6360549b}


Concept for norm implementations. 

\label{group__ConceptGroup_ga8b6032c46f6e31840a2c956c6360549b_NormConceptAnchor}%
\hypertarget{group__ConceptGroup_ga8b6032c46f6e31840a2c956c6360549b_NormConceptAnchor}{}%
The minimal signature of a norm is\+: 
\begin{DoxyCode}
1 // My norm.
2 class MyNorm
3 \{
4 public:
5   // Copy constructor.
6   MyNorm(const MyNorm&);
7 
8   // Move constructor.
9   MyNorm(MyNorm&&);
10 
11   // Compute ||x||.
12   Real operator()(const ::Spacy::Vector& x) const;
13 \};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_gaf4f33b11d657c48566d961a013c92bd1_NormAnchor}{\+:\+:Spacy\+:\+:Norm}. \hypertarget{group__ConceptGroup_ga7d984281b647a6d8e4c0a7ea5faeb90e_ga7d984281b647a6d8e4c0a7ea5faeb90e}{}\index{Concepts@{Concepts}!Operator\+Concept@{Operator\+Concept}}
\index{Operator\+Concept@{Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Operator\+Concept} = typedef boost\+::mpl\+::vector$<$ Callable\+Operator\+Concept , has\+\_\+domain$<$const Vector\+Space\&(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+range$<$const Vector\+Space\&(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga7d984281b647a6d8e4c0a7ea5faeb90e_ga7d984281b647a6d8e4c0a7ea5faeb90e}


Concept defining general operators. 

\label{group__ConceptGroup_ga7d984281b647a6d8e4c0a7ea5faeb90e_OperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_ga7d984281b647a6d8e4c0a7ea5faeb90e_OperatorConceptAnchor}{}%
The minimal signature of an operator is\+: 
\begin{DoxyCode}
1 // My operator A: X->Y.
2 class MyOperator
3 \{
4 public:
5   // Copy constructor.
6   MyOperator(const MyOperator&);
7 
8   // Move constructor.
9   MyOperator(MyOperator&&);
10 
11   // Compute A(x).
12   ::Spacy::Vector operator()(const ::Spacy::Vector& x) const;
13 
14   // Access domain space.
15   const VectorSpace& domain() const;
16 
17   // Access range space.
18   const VectorSpace& range() const;
19 \};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_ga3f89622eba80cf840b2a7102f1303455_OperatorAnchor}{\+:\+:Spacy\+:\+:Operator}. \hypertarget{group__ConceptGroup_ga1308724cda3078f228fb05c29556805d_ga1308724cda3078f228fb05c29556805d}{}\index{Concepts@{Concepts}!Scalar\+Product\+Concept@{Scalar\+Product\+Concept}}
\index{Scalar\+Product\+Concept@{Scalar\+Product\+Concept}!Concepts@{Concepts}}
\subsubsection[{Scalar\+Product\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Scalar\+Product\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::callable$<$Real(const Vector\&, const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga1308724cda3078f228fb05c29556805d_ga1308724cda3078f228fb05c29556805d}


Concept for scalar products. 

\label{group__ConceptGroup_ga1308724cda3078f228fb05c29556805d_ScalarProductConceptAnchor}%
\hypertarget{group__ConceptGroup_ga1308724cda3078f228fb05c29556805d_ScalarProductConceptAnchor}{}%
The minimal signature of a scalar product is\+: 
\begin{DoxyCode}
1 // My scalar product.
2 class MyScalarProduct
3 \{
4 public:
5   // Copy constructor.
6   MyScalarProduct(const MyScalarProduct&);
7 
8   // Move constructor.
9   MyScalarProduct(MyScalarProduct&&);
10 
11   // Compute (x,y).
12   Real operator()(const ::Spacy::Vector& x, const ::Spacy::Vector& y) const;
13 \};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_ga9fe0b4de20da1ab1ca3d04a0f96343e1_ScalarProductAnchor}{\+:\+:Spacy\+:\+:Scalar\+Product}. \hypertarget{group__ConceptGroup_ga45ecfe57ffb996aa97c9ff89a647f095_ga45ecfe57ffb996aa97c9ff89a647f095}{}\index{Concepts@{Concepts}!Time\+Integrator\+Concept@{Time\+Integrator\+Concept}}
\index{Time\+Integrator\+Concept@{Time\+Integrator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Time\+Integrator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Time\+Integrator\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::callable$<$Vector(double, const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+set\+Time\+Step$<$void(double)$>$ $>$}\label{group__ConceptGroup_ga45ecfe57ffb996aa97c9ff89a647f095_ga45ecfe57ffb996aa97c9ff89a647f095}


Concept for time integrators. 

\label{group__ConceptGroup_ga45ecfe57ffb996aa97c9ff89a647f095_TimeIntegratorConceptAnchor}%
\hypertarget{group__ConceptGroup_ga45ecfe57ffb996aa97c9ff89a647f095_TimeIntegratorConceptAnchor}{}%
The minimal signature of a time integrator is\+: 
\begin{DoxyCode}
1 // My scalar product.
2 class MyTimeIntegrator
3 \{
4 public:
5   // Copy constructor.
6   MyTimeIntegrator(const MyTimeIntegrator&);
7 
8   // Move constructor.
9   MyTimeIntegrator(MyTimeIntegrator&&);
10 
11   // Compute (x,y).
12   Vector operator()(double t, const ::Spacy::Vector& x) const;
13 
14   // Set time step.
15   void setTimeStep(double dt);
16 \};
\end{DoxyCode}


See \+:\+:Spacy\+:\+:Time\+Integrator. \hypertarget{group__ConceptGroup_gad6958389d1fa2758a8a64a0a24c36004_gad6958389d1fa2758a8a64a0a24c36004}{}\index{Concepts@{Concepts}!Vector\+Concept@{Vector\+Concept}}
\index{Vector\+Concept@{Vector\+Concept}!Concepts@{Concepts}}
\subsubsection[{Vector\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Vector\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::assignable$<$$>$ , boost\+::type\+\_\+erasure\+::multiply\+\_\+assignable$<$ boost\+::type\+\_\+erasure\+::\+\_\+self , double $>$ , boost\+::type\+\_\+erasure\+::add\+\_\+assignable$<$$>$ , boost\+::type\+\_\+erasure\+::subtract\+\_\+assignable$<$$>$ , boost\+::type\+\_\+erasure\+::negatable$<$$>$ , boost\+::type\+\_\+erasure\+::equality\+\_\+comparable$<$$>$ , boost\+::type\+\_\+erasure\+::callable$<$Vector(const boost\+::type\+\_\+erasure\+::\+\_\+self\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+space$<$const Vector\+Space$\ast$(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+to\+File$<$void(const std\+::string\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_gad6958389d1fa2758a8a64a0a24c36004_gad6958389d1fa2758a8a64a0a24c36004}


Concept for vector implementations. 

\label{group__ConceptGroup_gad6958389d1fa2758a8a64a0a24c36004_VectorConceptAnchor}%
\hypertarget{group__ConceptGroup_gad6958389d1fa2758a8a64a0a24c36004_VectorConceptAnchor}{}%
The minimal signature of a vector is\+: 
\begin{DoxyCode}
1 // My vector.
2 class MyVector
3 \{
4 public:
5   // Copy constructor.
6   MyVector(const MyVector&);
7 
8   // Move constructor.
9   MyVector(MyVector&&);
10 
11   // Copy assignable x=y.
12   MyVector& operator=(const MyVector& y);
13 
14   // In-place summation x+=y.
15   MyVector& operator+=(const MyVector& y);
16 
17   // In-place subtraction x-=y.
18   MyVector& operator-=(const MyVector& y);
19 
20   // In-place multiplication x*=a.
21   MyVector& operator*=(double a);
22 
23   // Negation -y.
24   MyVector operator-(const MyVector& y);
25 
26   // Equality comparison x==y.
27   bool operator==(const MyVector& y);
28 
29   // Apply as dual element x(y).
30   Vector operator()(const MyVector& y);
31 
32   // Access pointer to underlying function space.
33   const VectorSpace* space() const;
34 \};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_gafc144d2730ef87a67e54f8cd750b1f54_VectorAnchor}{\+:\+:Spacy\+:\+:Vector}. \hypertarget{group__ConceptGroup_ga3064301642b7c66b1b08f88a12a04645_ga3064301642b7c66b1b08f88a12a04645}{}\index{Concepts@{Concepts}!Vector\+Creator\+Concept@{Vector\+Creator\+Concept}}
\index{Vector\+Creator\+Concept@{Vector\+Creator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Vector\+Creator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Vector\+Creator\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::callable$<$boost\+::type\+\_\+erasure\+::any$<$Vector\+Concept$>$(const Vector\+Space$\ast$), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga3064301642b7c66b1b08f88a12a04645_ga3064301642b7c66b1b08f88a12a04645}


\hyperlink{classSpacy_1_1Vector}{Vector} creator concept. 

\label{group__ConceptGroup_ga3064301642b7c66b1b08f88a12a04645_VectorCreatorConceptAnchor}%
\hypertarget{group__ConceptGroup_ga3064301642b7c66b1b08f88a12a04645_VectorCreatorConceptAnchor}{}%
\begin{DoxySeeAlso}{See also}
\hyperlink{classSpacy_1_1VectorSpace}{Vector\+Space}, \hyperlink{group__SpacyGroup_ga1f5316487c031a478247206764bb2efb_VectorCreatorAnchor}{Vector\+Creator}. 
\end{DoxySeeAlso}
