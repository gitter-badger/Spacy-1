\hypertarget{group__ConceptGroup}{}\section{Concepts}
\label{group__ConceptGroup}\index{Concepts@{Concepts}}


Concepts for vectors, functionals, operators, ...  


\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \hyperlink{namespaceSpacy}{Spacy}
\begin{DoxyCompactList}\small\item\em Main namespace of the Spacy library. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class Impl $>$ }\\using \hyperlink{group__ConceptGroup_ga61ea9fe1d23e9f45e4e5fe940fe0e0cb}{Spacy\+::\+C1\+Operator\+Concept} = std\+::integral\+\_\+constant$<$ bool, Operator\+Concept$<$ Impl $>$\+::value \&\&Has\+Mem\+Fn\+\_\+d1\+\_\+\+Operator$<$ Impl, Vector $>$\+::value \&\&Has\+Mem\+Fn\+\_\+linearization$<$ Impl, Vector $>$\+::value $>$
\item 
{\footnotesize template$<$class Impl $>$ }\\using \hyperlink{group__ConceptGroup_ga265f0821ce6e0688d6e9abb8d8e0af6a}{Spacy\+::\+C2\+Functional\+Concept} = std\+::integral\+\_\+constant$<$ bool, C1\+Functional\+Concept$<$ Impl $>$\+::value \&\&Has\+Mem\+Fn\+\_\+d2\+\_\+\+Functional$<$ Impl, Vector $>$\+::value \&\&Has\+Mem\+Fn\+\_\+hessian$<$ Impl, Vector $>$\+::value $>$
\item 
{\footnotesize template$<$class T $>$ }\\using \hyperlink{group__ConceptGroup_ga5a296e4942cbfeba1e8538594a6e9c26}{Spacy\+::\+C\+G\+::\+Termination\+Criterion\+Concept} = std\+::integral\+\_\+constant$<$ bool, Has\+Mem\+Op\+\_\+variadic\+Callable$<$ bool $>$\+::template apply$<$ T $>$\+::value \&\&Has\+Mem\+Fn\+\_\+clear$<$ T $>$\+::value \&\&Has\+Mem\+Fn\+\_\+update$<$ T $>$\+::value \&\&Has\+Mem\+Fn\+\_\+vanishing\+Step$<$ T $>$\+::value \&\&Has\+Mem\+Fn\+\_\+minimal\+Decrease\+Achieved$<$ T $>$\+::value \&\&Has\+Mem\+Fn\+\_\+set\+Eps$<$ T $>$\+::value \&\&Has\+Mem\+Fn\+\_\+set\+Absolute\+Accuracy$<$ T $>$\+::value \&\&Has\+Mem\+Fn\+\_\+set\+Relative\+Accuracy$<$ T $>$\+::value \&\&Has\+Mem\+Fn\+\_\+set\+Minimal\+Accuracy$<$ T $>$\+::value $>$
\item 
{\footnotesize template$<$class Impl $>$ }\\using \hyperlink{group__ConceptGroup_gae45328d2e01ef6c8e5d948b69fda385f}{Spacy\+::\+Functional\+Concept} = std\+::integral\+\_\+constant$<$ bool, Has\+Mem\+Op\+\_\+callable$<$ Impl, Vector, Real $>$\+::value \&\&Has\+Mem\+Fn\+\_\+domain$<$ Impl $>$\+::value $>$
\begin{DoxyCompactList}\small\item\em Concept for functionals in Spacy. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Impl $>$ }\\using \hyperlink{group__ConceptGroup_ga8d3bdfc9abd844ab446a31fcd3f8ef8c}{Spacy\+::\+Linear\+Operator\+Concept} = std\+::integral\+\_\+constant$<$ bool, Vector\+Concept$<$ Impl $>$\+::value \&\&Operator\+Concept$<$ Impl $>$\+::value \&\&Has\+Mem\+Fn\+\_\+solver$<$ Impl $>$\+::value $>$
\item 
{\footnotesize template$<$class Impl $>$ }\\using \hyperlink{group__ConceptGroup_ga0cd6ba53feff75abbb6822b45fd6265e}{Spacy\+::\+Operator\+Concept} = std\+::integral\+\_\+constant$<$ bool, Has\+Mem\+Op\+\_\+callable$<$ Impl, Vector, Vector $>$\+::value \&\&Has\+Mem\+Fn\+\_\+domain$<$ Impl $>$\+::value \&\&Has\+Mem\+Fn\+\_\+range$<$ Impl $>$\+::value $>$
\item 
{\footnotesize template$<$class Impl $>$ }\\using \hyperlink{group__ConceptGroup_gac8fbeed0f838941e90ebe635a546e1db}{Spacy\+::\+Vector\+Concept} = std\+::integral\+\_\+constant$<$ bool, std\+::is\+\_\+copy\+\_\+constructible$<$ Impl $>$\+::value \&\&std\+::is\+\_\+copy\+\_\+assignable$<$ Impl $>$\+::value \&\&Has\+Mem\+Op\+\_\+add$<$ Impl $>$\+::value \&\&Has\+Mem\+Op\+\_\+subtract$<$ Impl $>$\+::value \&\&Has\+Mem\+Op\+\_\+multiply$<$ Impl $>$\+::value \&\&Has\+Mem\+Op\+\_\+negate$<$ Impl $>$\+::value \&\&Has\+Mem\+Fn\+\_\+space$<$ Impl $>$\+::value \&\&Is\+Void$<$ Impl $>$\+::template apply$<$ Try\+Mem\+Fn\+\_\+to\+File $>$\+::value $>$
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Concepts for vectors, functionals, operators, ... 



\subsection{Typedef Documentation}
\hypertarget{group__ConceptGroup_ga61ea9fe1d23e9f45e4e5fe940fe0e0cb}{}\index{Concepts@{Concepts}!C1\+Operator\+Concept@{C1\+Operator\+Concept}}
\index{C1\+Operator\+Concept@{C1\+Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{C1\+Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ using {\bf Spacy\+::\+C1\+Operator\+Concept} = typedef std\+::integral\+\_\+constant$<$ bool , Operator\+Concept$<$Impl$>$\+::value \&\& Has\+Mem\+Fn\+\_\+d1\+\_\+\+Operator$<$Impl,Vector$>$\+::value \&\& Has\+Mem\+Fn\+\_\+linearization$<$Impl,Vector$>$\+::value $>$}\label{group__ConceptGroup_ga61ea9fe1d23e9f45e4e5fe940fe0e0cb}
\label{group__ConceptGroup_C1OperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_C1OperatorConceptAnchor}{}%
 
\begin{DoxyCode}
\textcolor{comment}{// A: X->Y.}
\textcolor{keyword}{class }MyOperator
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Compute A(x).}
  \hyperlink{classSpacy_1_1Vector}{Spacy::Vector} operator()(\textcolor{keyword}{const} \hyperlink{classSpacy_1_1Vector}{Spacy::Vector}& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Compute A'(x)dx.}
  \hyperlink{classSpacy_1_1Vector}{Spacy::Vector} \hyperlink{namespaceSpacy_ab6646eb7068eb9f1369e639cf0b620a2}{d1}(\textcolor{keyword}{const} \hyperlink{classSpacy_1_1Vector}{Spacy::Vector}& x, \textcolor{keyword}{const} 
      \hyperlink{classSpacy_1_1Vector}{Spacy::Vector}& dx) \textcolor{keyword}{const};

  \textcolor{comment}{// Get linearization representing A'(x).}
 \hyperlink{classSpacy_1_1LinearOperator}{Spacy::LinearOperator} linearization(\textcolor{keyword}{const} \hyperlink{classSpacy_1_1Vector}{Spacy::Vector}& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Access domain space X.}
  \textcolor{keyword}{const} \hyperlink{classSpacy_1_1VectorSpace}{Spacy::VectorSpace}& domain() \textcolor{keyword}{const};

  \textcolor{comment}{// Access range space Y.}
  \textcolor{keyword}{const} \hyperlink{classSpacy_1_1VectorSpace}{Spacy::VectorSpace}& range() \textcolor{keyword}{const};
\};
\end{DoxyCode}


The member function {\ttfamily linearization(x)} is allowed to return any type that satisfies the Linear\+Operator\+Concept.

\begin{DoxySeeAlso}{See also}
\hyperlink{group__ConceptGroup_ga0cd6ba53feff75abbb6822b45fd6265e}{Operator\+Concept}, \hyperlink{classSpacy_1_1C1Operator}{C1\+Operator} 
\end{DoxySeeAlso}
\hypertarget{group__ConceptGroup_ga265f0821ce6e0688d6e9abb8d8e0af6a}{}\index{Concepts@{Concepts}!C2\+Functional\+Concept@{C2\+Functional\+Concept}}
\index{C2\+Functional\+Concept@{C2\+Functional\+Concept}!Concepts@{Concepts}}
\subsubsection[{C2\+Functional\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ using {\bf Spacy\+::\+C2\+Functional\+Concept} = typedef std\+::integral\+\_\+constant$<$ bool , C1\+Functional\+Concept$<$Impl$>$\+::value \&\& Has\+Mem\+Fn\+\_\+d2\+\_\+\+Functional$<$Impl,Vector$>$\+::value \&\& Has\+Mem\+Fn\+\_\+hessian$<$Impl,Vector$>$\+::value $>$}\label{group__ConceptGroup_ga265f0821ce6e0688d6e9abb8d8e0af6a}
\label{group__ConceptGroup_C2FunctionalConceptAnchor}%
\hypertarget{group__ConceptGroup_C2FunctionalConceptAnchor}{}%
 
\begin{DoxyCode}
\textcolor{comment}{// f: X->R.}
\textcolor{keyword}{class }MyFunctional
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Compute f(x).}
  \hyperlink{classSpacy_1_1Real}{Spacy::Real} operator()(\textcolor{keyword}{const} \hyperlink{classSpacy_1_1Vector}{Spacy::Vector}& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Compute f'(x) as element of the dual space X*.}
  \hyperlink{classSpacy_1_1Vector}{Spacy::Vector} \hyperlink{namespaceSpacy_ab6646eb7068eb9f1369e639cf0b620a2}{d1}(\textcolor{keyword}{const} \hyperlink{classSpacy_1_1Vector}{Spacy::Vector}& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Compute f''(x)dx as element of the dual space X*.}
  \hyperlink{classSpacy_1_1Vector}{Spacy::Vector} \hyperlink{namespaceSpacy_a569d8fc0b4a0e292f257dd6307a25c8f}{d2}(\textcolor{keyword}{const} \hyperlink{classSpacy_1_1Vector}{Spacy::Vector}& x, \textcolor{keyword}{const} 
      \hyperlink{classSpacy_1_1Vector}{Spacy::Vector}& dx) \textcolor{keyword}{const};

  \textcolor{comment}{// Access f''(x) as mapping f''(x): X->X*.}
  \hyperlink{classSpacy_1_1LinearOperator}{Spacy::LinearOperator} hessian(\textcolor{keyword}{const} \hyperlink{classSpacy_1_1Vector}{Spacy::Vector}& x);

  \textcolor{comment}{// Access underlying domain space X.}
  \textcolor{keyword}{const} \hyperlink{classSpacy_1_1VectorSpace}{Spacy::VectorSpace}& domain() \textcolor{keyword}{const};
\};
\end{DoxyCode}


The member function {\ttfamily hessian(x)} is allowed to return any type that satisfies the Linear\+Operator\+Concept.

\begin{DoxySeeAlso}{See also}
\hyperlink{group__ConceptGroup_gae45328d2e01ef6c8e5d948b69fda385f}{Functional\+Concept}, C1\+Functional\+Concept, \hyperlink{classSpacy_1_1C2Functional}{C2\+Functional} 
\end{DoxySeeAlso}
\hypertarget{group__ConceptGroup_ga5a296e4942cbfeba1e8538594a6e9c26}{}\index{Concepts@{Concepts}!Termination\+Criterion\+Concept@{Termination\+Criterion\+Concept}}
\index{Termination\+Criterion\+Concept@{Termination\+Criterion\+Concept}!Concepts@{Concepts}}
\subsubsection[{Termination\+Criterion\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ using {\bf Spacy\+::\+C\+G\+::\+Termination\+Criterion\+Concept} = typedef std\+::integral\+\_\+constant$<$ bool , Has\+Mem\+Op\+\_\+variadic\+Callable$<$bool$>$\+::template apply$<$T$>$\+::value \&\& Has\+Mem\+Fn\+\_\+clear$<$T$>$\+::value \&\& Has\+Mem\+Fn\+\_\+update$<$T$>$\+::value \&\& Has\+Mem\+Fn\+\_\+vanishing\+Step$<$T$>$\+::value \&\& Has\+Mem\+Fn\+\_\+minimal\+Decrease\+Achieved$<$T$>$\+::value \&\& Has\+Mem\+Fn\+\_\+set\+Eps$<$T$>$\+::value \&\& Has\+Mem\+Fn\+\_\+set\+Absolute\+Accuracy$<$T$>$\+::value \&\& Has\+Mem\+Fn\+\_\+set\+Relative\+Accuracy$<$T$>$\+::value \&\& Has\+Mem\+Fn\+\_\+set\+Minimal\+Accuracy$<$T$>$\+::value $>$}\label{group__ConceptGroup_ga5a296e4942cbfeba1e8538594a6e9c26}
\label{group__ConceptGroup_CG_TerminationCriterionConceptAnchor}%
\hypertarget{group__ConceptGroup_CG_TerminationCriterionConceptAnchor}{}%
 
\begin{DoxyCode}
\textcolor{keyword}{class }MyTerminationCriterion
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Check if termination criterion is satisfied.}
  \textcolor{keywordtype}{bool} operator()() \textcolor{keyword}{const};

  \textcolor{comment}{// Clear internal storage for new cg run.}
  \textcolor{keywordtype}{void} clear();

  \textcolor{comment}{// Provide algorithmic quantities required to evaluate termination criteria.}
  \textcolor{keywordtype}{void} update(\textcolor{keywordtype}{double} alpha, \textcolor{keywordtype}{double} qAq, \textcolor{keywordtype}{double} qPq, \textcolor{keywordtype}{double} rPINVr)

  \textcolor{comment}{// Checks if the step length of the computed step is below the maximal attainable accuracy.}
  \textcolor{keywordtype}{bool} vanishingStep() \textcolor{keyword}{const};

  \textcolor{comment}{// Checks if at least the minimal required decrease is satisfied. This is required for the}
  \textcolor{comment}{// truncated regularized conjugate gradient method (TRCG).}
  \textcolor{keywordtype}{bool} minimalDecreaseAchieved() \textcolor{keyword}{const};

  \textcolor{comment}{// Set maximal attainable accuracy}
  \textcolor{keywordtype}{void} setEps(\textcolor{keywordtype}{double});

  \textcolor{comment}{// Set relative accuracy.}
  \textcolor{keywordtype}{void} setRelativeAccuracy(\textcolor{keywordtype}{double});

  \textcolor{comment}{// Set absolute accuracy.}
  \textcolor{keywordtype}{void} setAbsoluteAccuracy(\textcolor{keywordtype}{double});

  \textcolor{comment}{// Set minimal accuracy. Only required for truncated regularized conjugate gradients (TRCG).}
  \textcolor{keywordtype}{void} setMinimalAccuracy(\textcolor{keywordtype}{double});
\};
\end{DoxyCode}


\begin{DoxySeeAlso}{See also}
\hyperlink{classSpacy_1_1CG_1_1TerminationCriterion}{C\+G\+::\+Termination\+Criterion} 
\end{DoxySeeAlso}
\hypertarget{group__ConceptGroup_gae45328d2e01ef6c8e5d948b69fda385f}{}\index{Concepts@{Concepts}!Functional\+Concept@{Functional\+Concept}}
\index{Functional\+Concept@{Functional\+Concept}!Concepts@{Concepts}}
\subsubsection[{Functional\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ using {\bf Spacy\+::\+Functional\+Concept} = typedef std\+::integral\+\_\+constant$<$ bool , Has\+Mem\+Op\+\_\+callable$<$Impl,Vector,Real$>$\+::value \&\& Has\+Mem\+Fn\+\_\+domain$<$Impl$>$\+::value $>$}\label{group__ConceptGroup_gae45328d2e01ef6c8e5d948b69fda385f}


Concept for functionals in Spacy. 

\label{group__ConceptGroup_FunctionalConceptGroup}%
\hypertarget{group__ConceptGroup_FunctionalConceptGroup}{}%

\begin{DoxyCode}
\textcolor{comment}{// f: X->R.}
\textcolor{keyword}{class }MyFunctional
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Compute f(x).}
  \hyperlink{classSpacy_1_1Real}{Spacy::Real} operator()(\textcolor{keyword}{const} \hyperlink{classSpacy_1_1Vector}{Spacy::Vector}& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Access underlying domain space X.}
  \textcolor{keyword}{const} \hyperlink{classSpacy_1_1VectorSpace}{Spacy::VectorSpace}& domain() \textcolor{keyword}{const};
\};
\end{DoxyCode}
 \begin{DoxySeeAlso}{See also}
\hyperlink{classSpacy_1_1Functional}{Functional} 
\end{DoxySeeAlso}
\hypertarget{group__ConceptGroup_ga8d3bdfc9abd844ab446a31fcd3f8ef8c}{}\index{Concepts@{Concepts}!Linear\+Operator\+Concept@{Linear\+Operator\+Concept}}
\index{Linear\+Operator\+Concept@{Linear\+Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Linear\+Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ using {\bf Spacy\+::\+Linear\+Operator\+Concept} = typedef std\+::integral\+\_\+constant$<$ bool , Vector\+Concept$<$Impl$>$\+::value \&\& Operator\+Concept$<$Impl$>$\+::value \&\& Has\+Mem\+Fn\+\_\+solver$<$Impl$>$\+::value $>$}\label{group__ConceptGroup_ga8d3bdfc9abd844ab446a31fcd3f8ef8c}
\label{group__ConceptGroup_LinearOperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_LinearOperatorConceptAnchor}{}%
 
\begin{DoxyCode}
\textcolor{comment}{// A: X->Y.}
\textcolor{keyword}{class }MyOperator
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor.}
  MyOperator(\textcolor{keyword}{const} MyOperator&);

  \textcolor{comment}{// Copy assignable x=y.}
  MyOperator& operator=(\textcolor{keyword}{const} MyOperator& y);

  \textcolor{comment}{// Compute A(x).}
  \hyperlink{classSpacy_1_1Vector}{::Spacy::Vector} operator()(\hyperlink{group__VectorSpaceGroup_gafda42fd5aa3f7597a42b9831bf4dfd07}{const ::Spacy::Vector}& x) \textcolor{keyword}{const};

  \textcolor{comment}{// In-place summation x+=y.}
  MyOperator& operator+=(\textcolor{keyword}{const} MyOperator& y);

  \textcolor{comment}{// In-place subtraction x-=y.}
  MyOperator& operator-=(\textcolor{keyword}{const} MyOperator& y);

  \textcolor{comment}{// In-place multiplication x*=a.}
  MyOperator& operator*=(\textcolor{keywordtype}{double} a);

  \textcolor{comment}{// Negation -y.}
  MyOperator \hyperlink{namespaceSpacy_a8bc98f51c7beab86185bf97a29b36395}{operator-}(\textcolor{keyword}{const} MyOperator& y);

  \textcolor{comment}{// Equality comparison x==y.}
  \textcolor{keywordtype}{bool} \hyperlink{namespaceSpacy_aef4930427aac4c8089b4c43b1c97cf25}{operator==}(\textcolor{keyword}{const} MyOperator& y);

  \textcolor{comment}{// Apply as dual element x(y).}
  Real operator()(\textcolor{keyword}{const} MyOperator& y);

  \textcolor{comment}{// Access pointer to underlying function space.}
  \textcolor{keyword}{const} \hyperlink{classSpacy_1_1VectorSpace}{Spacy::VectorSpace}& space() \textcolor{keyword}{const};

  \textcolor{comment}{// Access linear solver representing A(x)^-1}
 \hyperlink{namespaceSpacy_a4cd614ddb41dd29e68a723dadd5602f2}{Spacy::LinearSolver} solver() \textcolor{keyword}{const};

  \textcolor{comment}{// Access domain space X.}
  \textcolor{keyword}{const} \hyperlink{classSpacy_1_1VectorSpace}{Spacy::VectorSpace}& domain() \textcolor{keyword}{const};

  \textcolor{comment}{// Access range space Y.}
  \textcolor{keyword}{const} \hyperlink{classSpacy_1_1VectorSpace}{Spacy::VectorSpace}& range() \textcolor{keyword}{const};
\};
\end{DoxyCode}


The member function {\ttfamily solver()} is allowed to return anything that fits into a {\ttfamily std\+::function$<$Vector(const Vector\&)$>$}.

\begin{DoxySeeAlso}{See also}
\hyperlink{group__ConceptGroup_ga0cd6ba53feff75abbb6822b45fd6265e}{Operator\+Concept}, \hyperlink{group__ConceptGroup_gac8fbeed0f838941e90ebe635a546e1db}{Vector\+Concept}, \hyperlink{classSpacy_1_1LinearOperator}{Linear\+Operator} 
\end{DoxySeeAlso}
\hypertarget{group__ConceptGroup_ga0cd6ba53feff75abbb6822b45fd6265e}{}\index{Concepts@{Concepts}!Operator\+Concept@{Operator\+Concept}}
\index{Operator\+Concept@{Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ using {\bf Spacy\+::\+Operator\+Concept} = typedef std\+::integral\+\_\+constant$<$ bool , Has\+Mem\+Op\+\_\+callable$<$Impl,Vector,Vector$>$\+::value \&\& Has\+Mem\+Fn\+\_\+domain$<$Impl$>$\+::value \&\& Has\+Mem\+Fn\+\_\+range$<$Impl$>$\+::value $>$}\label{group__ConceptGroup_ga0cd6ba53feff75abbb6822b45fd6265e}
\label{group__ConceptGroup_OperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_OperatorConceptAnchor}{}%
 
\begin{DoxyCode}
\textcolor{comment}{// A: X->Y.}
\textcolor{keyword}{class }MyOperator
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Compute A(x).}
  \hyperlink{group__VectorSpaceGroup_gafda42fd5aa3f7597a42b9831bf4dfd07}{Vector} operator()(\textcolor{keyword}{const} \hyperlink{group__VectorSpaceGroup_gafda42fd5aa3f7597a42b9831bf4dfd07}{Vector}& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Access domain space X.}
  \textcolor{keyword}{const} VectorSpace& domain() \textcolor{keyword}{const};

  \textcolor{comment}{// Access range space Y.}
  \textcolor{keyword}{const} VectorSpace& range() \textcolor{keyword}{const};
\};
\end{DoxyCode}
 \begin{DoxySeeAlso}{See also}
\hyperlink{classSpacy_1_1Operator}{Operator} 
\end{DoxySeeAlso}
\hypertarget{group__ConceptGroup_gac8fbeed0f838941e90ebe635a546e1db}{}\index{Concepts@{Concepts}!Vector\+Concept@{Vector\+Concept}}
\index{Vector\+Concept@{Vector\+Concept}!Concepts@{Concepts}}
\subsubsection[{Vector\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ using {\bf Spacy\+::\+Vector\+Concept} = typedef std\+::integral\+\_\+constant$<$ bool , std\+::is\+\_\+copy\+\_\+constructible$<$Impl$>$\+::value \&\& std\+::is\+\_\+copy\+\_\+assignable$<$Impl$>$\+::value \&\& Has\+Mem\+Op\+\_\+add$<$Impl$>$\+::value \&\& Has\+Mem\+Op\+\_\+subtract$<$Impl$>$\+::value \&\& Has\+Mem\+Op\+\_\+multiply$<$Impl$>$\+::value \&\& Has\+Mem\+Op\+\_\+negate$<$Impl$>$\+::value \&\& Has\+Mem\+Fn\+\_\+space$<$Impl$>$\+::value \&\& Is\+Void$<$ Impl $>$\+::template apply$<$Try\+Mem\+Fn\+\_\+to\+File$>$\+::value $>$}\label{group__ConceptGroup_gac8fbeed0f838941e90ebe635a546e1db}

\begin{DoxyCode}
\textcolor{keyword}{class }MyVector
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor.}
  MyVector(\textcolor{keyword}{const} MyVector&);

  \textcolor{comment}{// Copy assignable x=y.}
  MyVector& operator=(\textcolor{keyword}{const} MyVector& y);

  \textcolor{comment}{// In-place summation x+=y.}
  MyVector& operator+=(\textcolor{keyword}{const} MyVector& y);

  \textcolor{comment}{// In-place subtraction x-=y.}
  MyVector& operator-=(\textcolor{keyword}{const} MyVector& y);

  \textcolor{comment}{// In-place multiplication x*=a.}
  MyVector& operator*=(\textcolor{keywordtype}{double} a);

  \textcolor{comment}{// Negation -y.}
  MyVector \hyperlink{namespaceSpacy_a8bc98f51c7beab86185bf97a29b36395}{operator-}(\textcolor{keyword}{const} MyVector& y);

  \textcolor{comment}{// Equality comparison x==y.}
  \textcolor{keywordtype}{bool} \hyperlink{namespaceSpacy_aef4930427aac4c8089b4c43b1c97cf25}{operator==}(\textcolor{keyword}{const} MyVector& y);

  \textcolor{comment}{// Apply as dual element x(y).}
  \hyperlink{classSpacy_1_1Real}{Spacy::Real} operator()(\textcolor{keyword}{const} MyVector& y);

  \textcolor{comment}{// Access pointer to underlying function space.}
  \textcolor{keyword}{const} \hyperlink{classSpacy_1_1VectorSpace}{Spacy::VectorSpace}& space() \textcolor{keyword}{const};
\};
\end{DoxyCode}


\begin{DoxySeeAlso}{See also}
\hyperlink{classSpacy_1_1Vector}{Spacy\+::\+Vector} 
\end{DoxySeeAlso}
