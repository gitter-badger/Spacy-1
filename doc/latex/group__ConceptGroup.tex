\hypertarget{group__ConceptGroup}{}\section{Concepts}
\label{group__ConceptGroup}\index{Concepts@{Concepts}}


Concepts for vectors, functional, operators, ...  


Collaboration diagram for Concepts\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=293pt]{group__ConceptGroup}
\end{center}
\end{figure}
\subsection*{Modules}
\begin{DoxyCompactItemize}
\item 
\hyperlink{group__NewtonConceptGroup}{Concepts for Newton\textquotesingle{}s method}
\begin{DoxyCompactList}\small\item\em Concepts for damping strategy and termination criteria for Newton\textquotesingle{}s method. \end{DoxyCompactList}\item 
\hyperlink{group__CGConceptGroup}{Concepts for conjugate gradient methods}
\begin{DoxyCompactList}\small\item\em Concept for termination criteria for conjugate gradient methods. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{group__ConceptGroup_ga63426675cc05ccce03ead56a4fa90d96_ga63426675cc05ccce03ead56a4fa90d96}{Spacy\+::\+Concepts\+::\+Concept\+Base} = boost\+::mpl\+::vector$<$ boost\+::type\+\_\+erasure\+::copy\+\_\+constructible$<$$>$, boost\+::type\+\_\+erasure\+::typeid\+\_\+$<$$>$, boost\+::type\+\_\+erasure\+::relaxed $>$
\begin{DoxyCompactList}\small\item\em Base concept. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga30692db093ead5a1a074905363a2f043_ga30692db093ead5a1a074905363a2f043}{Spacy\+::\+Concepts\+::\+Dynamic\+Callable\+Operator\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ Vector(double t, const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept defining the simplest possible time-\/dependent operator, only providing \hyperlink{classSpacy_1_1Vector}{Vector} operator()(double t, const Vector\&). \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga2c979d268f0ca7a436776a9631d10af7_ga2c979d268f0ca7a436776a9631d10af7}{Spacy\+::\+Concepts\+::\+Dynamic\+Operator\+Concept} = boost\+::mpl\+::vector$<$ Dynamic\+Callable\+Operator\+Concept, has\+\_\+\+M$<$ boost\+::type\+\_\+erasure\+::any$<$ Linear\+Operator\+Concept $>$(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+domain$<$ const Vector\+Space \&(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+range$<$ const Vector\+Space \&(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept defining general time-\/dependent operators. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga015b0d099011a2ef73a16aa9b36a7346_ga015b0d099011a2ef73a16aa9b36a7346}{Spacy\+::\+Concepts\+::\+Dynamic\+Linear\+Operator\+Concept} = boost\+::mpl\+::vector$<$ Dynamic\+Operator\+Concept, has\+\_\+solver$<$ const boost\+::type\+\_\+erasure\+::any$<$ Linear\+Solver\+Concept $>$ \&(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept defining time-\/dependent linear operators. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_gaa7ef0ce2d66b0610035541b580564b11_gaa7ef0ce2d66b0610035541b580564b11}{Spacy\+::\+Concepts\+::\+Dynamic\+C1\+Operator\+Concept} = boost\+::mpl\+::vector$<$ Dynamic\+Operator\+Concept, has\+\_\+d1$<$ Vector(double t, const Vector \&, const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+linearization$<$ boost\+::type\+\_\+erasure\+::any$<$ Linear\+Operator\+Concept $>$(double t, const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept defining time-\/dependent operators that are differentiable with respect to the spatial variable. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga6b5c97b0e58318ef98c43a9b8a7dae08_ga6b5c97b0e58318ef98c43a9b8a7dae08}{Spacy\+::\+Concepts\+::\+My\+Error\+Estimator\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ double(const Vector \&, const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+refine$<$ void()$>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for time integrators. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga5273b50bd3e8c9a3f5a1e6b5f170836d_ga5273b50bd3e8c9a3f5a1e6b5f170836d}{Spacy\+::\+Concepts\+::\+Functional\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ Real(const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+domain$<$ const Vector\+Space \&(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for functionals. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga205b55d8291e0f2e143f116cf78bc54f_ga205b55d8291e0f2e143f116cf78bc54f}{Spacy\+::\+Concepts\+::\+C1\+Functional\+Concept} = boost\+::mpl\+::vector$<$ Functional\+Concept, has\+\_\+d1\+\_\+dual$<$ Vector(const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for differentiable functionals. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_gafb4414561b07b27100cad81ecf152e47_gafb4414561b07b27100cad81ecf152e47}{Spacy\+::\+Concepts\+::\+C2\+Functional\+Concept} = boost\+::mpl\+::vector$<$ C1\+Functional\+Concept, has\+\_\+d2\+\_\+dual$<$ Vector(const Vector \&, const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+hessian$<$ boost\+::type\+\_\+erasure\+::any$<$ Linear\+Operator\+Concept $>$(const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for twice differentiable functionals. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_gac7d6a94c7131c8613e2ab26fddeb50bd_gac7d6a94c7131c8613e2ab26fddeb50bd}{Spacy\+::\+Concepts\+::\+Linear\+Solver\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ Vector(const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for linear solver implementations. Same as \hyperlink{group__ConceptGroup_gadec0c664abaacc2065dadd8b11cc8d30_CallableOperatorConceptAnchor}{Callable\+Operator\+Concept}. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga582dd34334cdecc7b27883f4e8239490_ga582dd34334cdecc7b27883f4e8239490}{Spacy\+::\+Concepts\+::\+Indefinite\+Linear\+Solver\+Concept} = boost\+::mpl\+::vector$<$ Linear\+Solver\+Concept, has\+\_\+is\+Positive\+Definite$<$ bool(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for linear solver implementations that monitor positive definiteness. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga8b6032c46f6e31840a2c956c6360549b_ga8b6032c46f6e31840a2c956c6360549b}{Spacy\+::\+Concepts\+::\+Norm\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ Real(const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for norm implementations. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_gadec0c664abaacc2065dadd8b11cc8d30_gadec0c664abaacc2065dadd8b11cc8d30}{Spacy\+::\+Concepts\+::\+Callable\+Operator\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ Vector(const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept defining the simplest possible operator, only providing \hyperlink{classSpacy_1_1Vector}{Vector} operator()(const Vector\&). \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga7d984281b647a6d8e4c0a7ea5faeb90e_ga7d984281b647a6d8e4c0a7ea5faeb90e}{Spacy\+::\+Concepts\+::\+Operator\+Concept} = boost\+::mpl\+::vector$<$ Callable\+Operator\+Concept, has\+\_\+domain$<$ const Vector\+Space \&(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+range$<$ const Vector\+Space \&(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept defining general operators. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_gaf0e18e41c434cfceb77ccb8e785a8055_gaf0e18e41c434cfceb77ccb8e785a8055}{Spacy\+::\+Concepts\+::\+Linear\+Operator\+Concept} = boost\+::mpl\+::vector$<$ Operator\+Concept, Vector\+Concept, has\+\_\+solver$<$ boost\+::type\+\_\+erasure\+::any$<$ Linear\+Solver\+Concept $>$(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept defining linear operators. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga14a12c741dc237e32862fa4bc315451b_ga14a12c741dc237e32862fa4bc315451b}{Spacy\+::\+Concepts\+::\+C1\+Operator\+Concept} = boost\+::mpl\+::vector$<$ Operator\+Concept, has\+\_\+d1$<$ Vector(const Vector \&, const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+linearization$<$ boost\+::type\+\_\+erasure\+::any$<$ Linear\+Operator\+Concept $>$(const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept defining differentiable operators. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga1308724cda3078f228fb05c29556805d_ga1308724cda3078f228fb05c29556805d}{Spacy\+::\+Concepts\+::\+Scalar\+Product\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ Real(const Vector \&, const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for scalar products. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga45ecfe57ffb996aa97c9ff89a647f095_ga45ecfe57ffb996aa97c9ff89a647f095}{Spacy\+::\+Concepts\+::\+Time\+Integrator\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ Vector(double, const Vector \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+set\+Time\+Step$<$ void(double)$>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for time integrators. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_gad6958389d1fa2758a8a64a0a24c36004_gad6958389d1fa2758a8a64a0a24c36004}{Spacy\+::\+Concepts\+::\+Vector\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::assignable$<$$>$, boost\+::type\+\_\+erasure\+::multiply\+\_\+assignable$<$ boost\+::type\+\_\+erasure\+::\+\_\+self, double $>$, boost\+::type\+\_\+erasure\+::add\+\_\+assignable$<$$>$, boost\+::type\+\_\+erasure\+::subtract\+\_\+assignable$<$$>$, boost\+::type\+\_\+erasure\+::negatable$<$$>$, boost\+::type\+\_\+erasure\+::equality\+\_\+comparable$<$$>$, boost\+::type\+\_\+erasure\+::callable$<$ Vector(const boost\+::type\+\_\+erasure\+::\+\_\+self \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+space$<$ const Vector\+Space $\ast$(), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$, has\+\_\+to\+File$<$ void(const std\+::string \&), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em Concept for vector implementations. \end{DoxyCompactList}\item 
using \hyperlink{group__ConceptGroup_ga3064301642b7c66b1b08f88a12a04645_ga3064301642b7c66b1b08f88a12a04645}{Spacy\+::\+Concepts\+::\+Vector\+Creator\+Concept} = boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$ boost\+::type\+\_\+erasure\+::any$<$ Vector\+Concept $>$(const Vector\+Space $\ast$), const boost\+::type\+\_\+erasure\+::\+\_\+self $>$ $>$
\begin{DoxyCompactList}\small\item\em \hyperlink{classSpacy_1_1Vector}{Vector} creator concept. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Concepts for vectors, functional, operators, ... 

The concepts are employed with Boost.\+Type\+Erasure, i.\+e. Vector\+Concept yields the type boost\+::type\+\_\+erasure\+::any$<$\+Vector\+Concept$>$. 

\subsection{Typedef Documentation}
\hypertarget{group__ConceptGroup_ga205b55d8291e0f2e143f116cf78bc54f_ga205b55d8291e0f2e143f116cf78bc54f}{}\index{Concepts@{Concepts}!C1\+Functional\+Concept@{C1\+Functional\+Concept}}
\index{C1\+Functional\+Concept@{C1\+Functional\+Concept}!Concepts@{Concepts}}
\subsubsection[{C1\+Functional\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+C1\+Functional\+Concept} = typedef boost\+::mpl\+::vector$<$ Functional\+Concept , has\+\_\+d1\+\_\+dual$<$Vector(const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga205b55d8291e0f2e143f116cf78bc54f_ga205b55d8291e0f2e143f116cf78bc54f}


Concept for differentiable functionals. 

\label{group__ConceptGroup_ga205b55d8291e0f2e143f116cf78bc54f_C1FunctionalConceptAnchor}%
\hypertarget{group__ConceptGroup_ga205b55d8291e0f2e143f116cf78bc54f_C1FunctionalConceptAnchor}{}%
The minimal signature of a differentiable functional is 
\begin{DoxyCode}
\textcolor{comment}{// A differentiable functional f: X->R.}
\textcolor{keyword}{class }MyC1Functional
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor, possibly default-generated.}
  MyC1Functional(\textcolor{keyword}{const} MyC1Functional&);

  \textcolor{comment}{// Move constructor, possibly default-generated.}
  MyC1Functional(MyC1Functional&&);

  \textcolor{comment}{// Compute f(x).}
  \textcolor{keywordtype}{double} operator()(const ::Spacy::Vector& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Compute f'(x) as element of X*.}
  \hyperlink{classSpacy_1_1Vector}{::Spacy::Vector} \hyperlink{group__SpacyGroup_gab6646eb7068eb9f1369e639cf0b620a2_gab6646eb7068eb9f1369e639cf0b620a2}{d1}(const ::Spacy::Vector& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Access underlying domain.}
  \textcolor{keyword}{const} VectorSpace& domain() \textcolor{keyword}{const};
\};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_gaa7cb8ef6c287b0af0352d3dd0eb9f200_C1FunctionalAnchor}{\+:\+:Spacy\+:\+:C1\+Functional}. \hypertarget{group__ConceptGroup_ga14a12c741dc237e32862fa4bc315451b_ga14a12c741dc237e32862fa4bc315451b}{}\index{Concepts@{Concepts}!C1\+Operator\+Concept@{C1\+Operator\+Concept}}
\index{C1\+Operator\+Concept@{C1\+Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{C1\+Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+C1\+Operator\+Concept} = typedef boost\+::mpl\+::vector$<$ Operator\+Concept , has\+\_\+d1$<$Vector(const Vector\&,const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+linearization$<$boost\+::type\+\_\+erasure\+::any$<$Linear\+Operator\+Concept$>$(const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga14a12c741dc237e32862fa4bc315451b_ga14a12c741dc237e32862fa4bc315451b}


Concept defining differentiable operators. 

\label{group__ConceptGroup_ga14a12c741dc237e32862fa4bc315451b_C1OperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_ga14a12c741dc237e32862fa4bc315451b_C1OperatorConceptAnchor}{}%
The minimal signature for a differentiable operator is\+: 
\begin{DoxyCode}
\textcolor{comment}{// My differentiable operator A: X->Y.}
\textcolor{keyword}{class }MyOperator
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor.}
  MyOperator(\textcolor{keyword}{const} MyOperator&);

  \textcolor{comment}{// Move constructor.}
  MyOperator(MyOperator&&);

  \textcolor{comment}{// Compute A(x).}
  \hyperlink{classSpacy_1_1Vector}{::Spacy::Vector} operator()(const ::Spacy::Vector& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Compute A'(x)dx.}
  \hyperlink{classSpacy_1_1Vector}{::Spacy::Vector} \hyperlink{group__SpacyGroup_gab6646eb7068eb9f1369e639cf0b620a2_gab6646eb7068eb9f1369e639cf0b620a2}{d1}(const ::Spacy::Vector& x, const ::Spacy::Vector& dx) \textcolor{keyword}{const};

  \textcolor{comment}{// Get linearization representing A'(x).}
 \hyperlink{group__SpacyGroup_ga584f7b9d82a844302ba0d77c3a1b6640_ga584f7b9d82a844302ba0d77c3a1b6640}{::Spacy::LinearOperator} linearization(const ::Spacy::Vector& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Access domain space.}
  \textcolor{keyword}{const} VectorSpace& domain() \textcolor{keyword}{const};

  \textcolor{comment}{// Access range space.}
  \textcolor{keyword}{const} VectorSpace& range() \textcolor{keyword}{const};
\};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_ga87ae8cb0d7a567a4bb181e0a9f182620_C1OperatorAnchor}{\+:\+:Spacy\+:\+:C1\+Operator}. \hypertarget{group__ConceptGroup_gafb4414561b07b27100cad81ecf152e47_gafb4414561b07b27100cad81ecf152e47}{}\index{Concepts@{Concepts}!C2\+Functional\+Concept@{C2\+Functional\+Concept}}
\index{C2\+Functional\+Concept@{C2\+Functional\+Concept}!Concepts@{Concepts}}
\subsubsection[{C2\+Functional\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+C2\+Functional\+Concept} = typedef boost\+::mpl\+::vector$<$ C1\+Functional\+Concept , has\+\_\+d2\+\_\+dual$<$Vector(const Vector\&,const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+hessian$<$boost\+::type\+\_\+erasure\+::any$<$Linear\+Operator\+Concept$>$(const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_gafb4414561b07b27100cad81ecf152e47_gafb4414561b07b27100cad81ecf152e47}


Concept for twice differentiable functionals. 

\label{group__ConceptGroup_gafb4414561b07b27100cad81ecf152e47_C2FunctionalConceptAnchor}%
\hypertarget{group__ConceptGroup_gafb4414561b07b27100cad81ecf152e47_C2FunctionalConceptAnchor}{}%
The minimal signature of a twice differentiable functional is 
\begin{DoxyCode}
\textcolor{comment}{// A twice differentiable functional f: X->R.}
\textcolor{keyword}{class }MyC2Functional
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor, possibly default-generated.}
  MyC2Functional(\textcolor{keyword}{const} MyC2Functional&);

  \textcolor{comment}{// Move constructor, possibly default-generated.}
  MyC2Functional(MyC2Functional&&);

  \textcolor{comment}{// Compute f(x).}
  \textcolor{keywordtype}{double} operator()(const ::Spacy::Vector& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Compute f'(x) as element of X*.}
  \hyperlink{classSpacy_1_1Vector}{::Spacy::Vector} \hyperlink{group__SpacyGroup_gab6646eb7068eb9f1369e639cf0b620a2_gab6646eb7068eb9f1369e639cf0b620a2}{d1}(const ::Spacy::Vector& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Compute f''(x)dx as element of X*.}
  \hyperlink{classSpacy_1_1Vector}{::Spacy::Vector} \hyperlink{group__SpacyGroup_ga22f56f6ffd46496e786b435cabca71e0_ga22f56f6ffd46496e786b435cabca71e0}{d2}(const ::Spacy::Vector& x, const ::Spacy::Vector& dx) \textcolor{keyword}{const};

  \textcolor{comment}{// Access f''(x) as mapping f''(x): X->X*.}
  \hyperlink{group__SpacyGroup_ga584f7b9d82a844302ba0d77c3a1b6640_ga584f7b9d82a844302ba0d77c3a1b6640}{LinearOperator} hessian(const ::Spacy::Vector& x);

  \textcolor{comment}{// Access underlying domain.}
  \textcolor{keyword}{const} VectorSpace& domain() \textcolor{keyword}{const};
\};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_gaf5b89e117806134b06a1ce4629fb2b65_C2FunctionalAnchor}{\+:\+:Spacy\+:\+:C2\+Functional}. \hypertarget{group__ConceptGroup_gadec0c664abaacc2065dadd8b11cc8d30_gadec0c664abaacc2065dadd8b11cc8d30}{}\index{Concepts@{Concepts}!Callable\+Operator\+Concept@{Callable\+Operator\+Concept}}
\index{Callable\+Operator\+Concept@{Callable\+Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Callable\+Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Callable\+Operator\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::callable$<$Vector(const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_gadec0c664abaacc2065dadd8b11cc8d30_gadec0c664abaacc2065dadd8b11cc8d30}


Concept defining the simplest possible operator, only providing \hyperlink{classSpacy_1_1Vector}{Vector} operator()(const Vector\&). 

\label{group__ConceptGroup_gadec0c664abaacc2065dadd8b11cc8d30_CallableOperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_gadec0c664abaacc2065dadd8b11cc8d30_CallableOperatorConceptAnchor}{}%
The minimal signature of a callable operator is\+: 
\begin{DoxyCode}
\textcolor{comment}{// My callable operator A: X->Y.}
\textcolor{keyword}{class }MyOperator
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor.}
  MyOperator(\textcolor{keyword}{const} MyOperator&);

  \textcolor{comment}{// Move constructor.}
  MyOperator(MyOperator&&);

  \textcolor{comment}{// Compute A(x).}
  \hyperlink{classSpacy_1_1Vector}{::Spacy::Vector} operator()(const ::Spacy::Vector& x) \textcolor{keyword}{const};
\};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_ga2b74020d806ad800795cdd97dab3466f_CallableOperatorAnchor}{\+:\+:Spacy\+:\+:Callable\+Operator}. \hypertarget{group__ConceptGroup_ga63426675cc05ccce03ead56a4fa90d96_ga63426675cc05ccce03ead56a4fa90d96}{}\index{Concepts@{Concepts}!Concept\+Base@{Concept\+Base}}
\index{Concept\+Base@{Concept\+Base}!Concepts@{Concepts}}
\subsubsection[{Concept\+Base}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Concept\+Base} = typedef boost\+::mpl\+::vector$<$ boost\+::type\+\_\+erasure\+::copy\+\_\+constructible$<$$>$ , boost\+::type\+\_\+erasure\+::typeid\+\_\+$<$$>$ , boost\+::type\+\_\+erasure\+::relaxed $>$}\label{group__ConceptGroup_ga63426675cc05ccce03ead56a4fa90d96_ga63426675cc05ccce03ead56a4fa90d96}


Base concept. 

Requires copy-\/constructability, provides run-\/time type information and some convenience functions with boost\+::type\+\_\+erasure\+::relaxed. \hypertarget{group__ConceptGroup_gaa7ef0ce2d66b0610035541b580564b11_gaa7ef0ce2d66b0610035541b580564b11}{}\index{Concepts@{Concepts}!Dynamic\+C1\+Operator\+Concept@{Dynamic\+C1\+Operator\+Concept}}
\index{Dynamic\+C1\+Operator\+Concept@{Dynamic\+C1\+Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Dynamic\+C1\+Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Dynamic\+C1\+Operator\+Concept} = typedef boost\+::mpl\+::vector$<$ Dynamic\+Operator\+Concept , has\+\_\+d1$<$Vector(double t, const Vector\&,const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+linearization$<$boost\+::type\+\_\+erasure\+::any$<$Linear\+Operator\+Concept$>$(double t, const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_gaa7ef0ce2d66b0610035541b580564b11_gaa7ef0ce2d66b0610035541b580564b11}


Concept defining time-\/dependent operators that are differentiable with respect to the spatial variable. 

\label{group__ConceptGroup_gaa7ef0ce2d66b0610035541b580564b11_DynamicC1OperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_gaa7ef0ce2d66b0610035541b580564b11_DynamicC1OperatorConceptAnchor}{}%
The minimal signature for a time-\/dependent differentiable operator is\+: 
\begin{DoxyCode}
\textcolor{comment}{// My differentiable operator A: [0,T[ \(\backslash\)times X -> Y.}
\textcolor{keyword}{class }MyOperator
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor.}
  MyOperator(\textcolor{keyword}{const} MyOperator&);

  \textcolor{comment}{// Move constructor.}
  MyOperator(MyOperator&&);

  \textcolor{comment}{// Compute A(t,x).}
  \hyperlink{classSpacy_1_1Vector}{::Spacy::Vector} operator()(\textcolor{keywordtype}{double} t, const ::Spacy::Vector& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Compute A\_x(t,x)dx.}
  \hyperlink{classSpacy_1_1Vector}{::Spacy::Vector} \hyperlink{group__SpacyGroup_gab6646eb7068eb9f1369e639cf0b620a2_gab6646eb7068eb9f1369e639cf0b620a2}{d1}(\textcolor{keywordtype}{double} t, const ::Spacy::Vector& x, const ::Spacy::Vector& dx) \textcolor{keyword}{const};

  \textcolor{comment}{// Get linearization representing A\_x(t,x).}
 \hyperlink{group__SpacyGroup_ga584f7b9d82a844302ba0d77c3a1b6640_ga584f7b9d82a844302ba0d77c3a1b6640}{::Spacy::LinearOperator} linearization(\textcolor{keywordtype}{double} t, const ::Spacy::Vector& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Access mass matrix.}
  \hyperlink{group__SpacyGroup_ga584f7b9d82a844302ba0d77c3a1b6640_ga584f7b9d82a844302ba0d77c3a1b6640}{LinearOperator} M() \textcolor{keyword}{const};

  \textcolor{comment}{// Access domain space.}
  \textcolor{keyword}{const} VectorSpace& domain() \textcolor{keyword}{const};

  \textcolor{comment}{// Access range space.}
  \textcolor{keyword}{const} VectorSpace& range() \textcolor{keyword}{const};
\};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_gabc9c830d2a7e020bcab097b10ee6f642_DynamicC1OperatorAnchor}{\+:\+:Spacy\+:\+:Dynamic\+C1\+Operator}. \hypertarget{group__ConceptGroup_ga30692db093ead5a1a074905363a2f043_ga30692db093ead5a1a074905363a2f043}{}\index{Concepts@{Concepts}!Dynamic\+Callable\+Operator\+Concept@{Dynamic\+Callable\+Operator\+Concept}}
\index{Dynamic\+Callable\+Operator\+Concept@{Dynamic\+Callable\+Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Dynamic\+Callable\+Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Dynamic\+Callable\+Operator\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::callable$<$Vector(double t, const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga30692db093ead5a1a074905363a2f043_ga30692db093ead5a1a074905363a2f043}


Concept defining the simplest possible time-\/dependent operator, only providing \hyperlink{classSpacy_1_1Vector}{Vector} operator()(double t, const Vector\&). 

\label{group__ConceptGroup_ga30692db093ead5a1a074905363a2f043_DynamicCallableOperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_ga30692db093ead5a1a074905363a2f043_DynamicCallableOperatorConceptAnchor}{}%
The minimal signature of a time-\/dependent callable operator is\+: 
\begin{DoxyCode}
\textcolor{comment}{// My callable operator A: [0,T[ \(\backslash\)times X -> Y.}
\textcolor{keyword}{class }MyOperator
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor.}
  MyOperator(\textcolor{keyword}{const} MyOperator&);

  \textcolor{comment}{// Move constructor.}
  MyOperator(MyOperator&&);

  \textcolor{comment}{// Compute A(t,x).}
  \hyperlink{classSpacy_1_1Vector}{::Spacy::Vector} operator()(\textcolor{keywordtype}{double} t, const ::Spacy::Vector& x) \textcolor{keyword}{const};
\};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_ga750d55072f7a3a16a1263961147333c0_DynamicCallableOperatorAnchor}{\+:\+:Spacy\+:\+:Dynamic\+Callable\+Operator}. \hypertarget{group__ConceptGroup_ga015b0d099011a2ef73a16aa9b36a7346_ga015b0d099011a2ef73a16aa9b36a7346}{}\index{Concepts@{Concepts}!Dynamic\+Linear\+Operator\+Concept@{Dynamic\+Linear\+Operator\+Concept}}
\index{Dynamic\+Linear\+Operator\+Concept@{Dynamic\+Linear\+Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Dynamic\+Linear\+Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Dynamic\+Linear\+Operator\+Concept} = typedef boost\+::mpl\+::vector$<$ Dynamic\+Operator\+Concept , has\+\_\+solver$<$const boost\+::type\+\_\+erasure\+::any$<$Linear\+Solver\+Concept$>$\&(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga015b0d099011a2ef73a16aa9b36a7346_ga015b0d099011a2ef73a16aa9b36a7346}


Concept defining time-\/dependent linear operators. 

\label{group__ConceptGroup_ga015b0d099011a2ef73a16aa9b36a7346_DynamicLinearOperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_ga015b0d099011a2ef73a16aa9b36a7346_DynamicLinearOperatorConceptAnchor}{}%
The minimal signature of a time-\/dependent linear operator is\+: 
\begin{DoxyCode}
\textcolor{comment}{// My linear operator A: [0,T[ \(\backslash\)times X -> Y.}
\textcolor{keyword}{class }MyLinearOperator
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor.}
  MyLinearOperator(\textcolor{keyword}{const} MyLinearOperator&);

  \textcolor{comment}{// Move constructor.}
  MyLinearOperator(MyLinearOperator&&);

  \textcolor{comment}{// Compute A(t,x).}
  \hyperlink{classSpacy_1_1Vector}{::Spacy::Vector} operator()(\textcolor{keywordtype}{double} t, const ::Spacy::Vector& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Access solver for the computation of A(t)^-1.}
  \hyperlink{namespaceSpacy_a7d5cd1c6fb9dd85aa345b536caf30bba_a7d5cd1c6fb9dd85aa345b536caf30bba}{::Spacy::LinearSolver} solver() \textcolor{keyword}{const};

  \textcolor{comment}{// Access domain space.}
  \textcolor{keyword}{const} VectorSpace& domain() \textcolor{keyword}{const};

  \textcolor{comment}{// Access range space.}
  \textcolor{keyword}{const} VectorSpace& range() \textcolor{keyword}{const};
\};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_gaad10aa7d5443703377b768fa41a3c7ea_DynamicLinearOperatorAnchor}{\+:\+:Spacy\+:\+:Dynamic\+Linear\+Operator}. \hypertarget{group__ConceptGroup_ga2c979d268f0ca7a436776a9631d10af7_ga2c979d268f0ca7a436776a9631d10af7}{}\index{Concepts@{Concepts}!Dynamic\+Operator\+Concept@{Dynamic\+Operator\+Concept}}
\index{Dynamic\+Operator\+Concept@{Dynamic\+Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Dynamic\+Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Dynamic\+Operator\+Concept} = typedef boost\+::mpl\+::vector$<$ Dynamic\+Callable\+Operator\+Concept , has\+\_\+\+M$<$boost\+::type\+\_\+erasure\+::any$<$ Linear\+Operator\+Concept $>$(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+domain$<$const Vector\+Space\&(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+range$<$const Vector\+Space\&(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga2c979d268f0ca7a436776a9631d10af7_ga2c979d268f0ca7a436776a9631d10af7}


Concept defining general time-\/dependent operators. 

\label{group__ConceptGroup_ga2c979d268f0ca7a436776a9631d10af7_DynamicOperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_ga2c979d268f0ca7a436776a9631d10af7_DynamicOperatorConceptAnchor}{}%
The minimal signature of a time-\/dependent operator is\+: 
\begin{DoxyCode}
\textcolor{comment}{// My operator A: [0,T[ \(\backslash\)times X -> Y.}
\textcolor{keyword}{class }MyOperator
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor.}
  MyOperator(\textcolor{keyword}{const} MyOperator&);

  \textcolor{comment}{// Move constructor.}
  MyOperator(MyOperator&&);

  \textcolor{comment}{// Compute A(t,x).}
  \hyperlink{classSpacy_1_1Vector}{::Spacy::Vector} operator()(\textcolor{keywordtype}{double} t, const ::Spacy::Vector& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Access domain space.}
  \textcolor{keyword}{const} VectorSpace& domain() \textcolor{keyword}{const};

  \textcolor{comment}{// Access mass matrix.}
  \hyperlink{group__SpacyGroup_ga584f7b9d82a844302ba0d77c3a1b6640_ga584f7b9d82a844302ba0d77c3a1b6640}{LinearOperator} M() \textcolor{keyword}{const};

  \textcolor{comment}{// Access range space.}
  \textcolor{keyword}{const} VectorSpace& range() \textcolor{keyword}{const};
\};
\end{DoxyCode}


See \+:\+:Spacy\+:\+:Dynamic\+Operator. \hypertarget{group__ConceptGroup_ga5273b50bd3e8c9a3f5a1e6b5f170836d_ga5273b50bd3e8c9a3f5a1e6b5f170836d}{}\index{Concepts@{Concepts}!Functional\+Concept@{Functional\+Concept}}
\index{Functional\+Concept@{Functional\+Concept}!Concepts@{Concepts}}
\subsubsection[{Functional\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Functional\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base, boost\+::type\+\_\+erasure\+::callable$<$Real(const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$, has\+\_\+domain$<$const Vector\+Space\&(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga5273b50bd3e8c9a3f5a1e6b5f170836d_ga5273b50bd3e8c9a3f5a1e6b5f170836d}


Concept for functionals. 

\label{group__ConceptGroup_ga5273b50bd3e8c9a3f5a1e6b5f170836d_FunctionalConceptAnchor}%
\hypertarget{group__ConceptGroup_ga5273b50bd3e8c9a3f5a1e6b5f170836d_FunctionalConceptAnchor}{}%
The minimal signature of a functional is\+: 
\begin{DoxyCode}
\textcolor{comment}{// A functional f: X->R.}
\textcolor{keyword}{class }MyFunctional
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Compute f(x).}
  \textcolor{keywordtype}{double} operator()(const ::Spacy::Vector& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Access underlying domain.}
  \textcolor{keyword}{const} VectorSpace& domain() \textcolor{keyword}{const};
\};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_ga673218f603c93790864aef12c89d3a35_FunctionalAnchor}{\+:\+:Spacy\+:\+:Functional}. \hypertarget{group__ConceptGroup_ga582dd34334cdecc7b27883f4e8239490_ga582dd34334cdecc7b27883f4e8239490}{}\index{Concepts@{Concepts}!Indefinite\+Linear\+Solver\+Concept@{Indefinite\+Linear\+Solver\+Concept}}
\index{Indefinite\+Linear\+Solver\+Concept@{Indefinite\+Linear\+Solver\+Concept}!Concepts@{Concepts}}
\subsubsection[{Indefinite\+Linear\+Solver\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Indefinite\+Linear\+Solver\+Concept} = typedef boost\+::mpl\+::vector$<$ Linear\+Solver\+Concept , has\+\_\+is\+Positive\+Definite$<$bool(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga582dd34334cdecc7b27883f4e8239490_ga582dd34334cdecc7b27883f4e8239490}


Concept for linear solver implementations that monitor positive definiteness. 

\label{group__ConceptGroup_ga582dd34334cdecc7b27883f4e8239490_IndefiniteLinearSolverConceptAnchor}%
\hypertarget{group__ConceptGroup_ga582dd34334cdecc7b27883f4e8239490_IndefiniteLinearSolverConceptAnchor}{}%
The minimal signature of a general linear solver is\+: 
\begin{DoxyCode}
\textcolor{comment}{// My general linear solver S representing A^-1.}
\textcolor{keyword}{class }MyIndefiniteLinearSolver
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor.}
  MyIndefiniteLinearSolver(\textcolor{keyword}{const} MyIndefiniteLinearSolver&);

  \textcolor{comment}{// Move constructor.}
  MyIndefiniteLinearSolver(MyIndefiniteLinearSolver&&);

  \textcolor{comment}{// Compute A^-1(x).}
  \hyperlink{classSpacy_1_1Vector}{::Spacy::Vector} operator()(const ::Spacy::Vector& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Check if A is positive definite}
  \textcolor{keywordtype}{bool} isPositiveDefinite() \textcolor{keyword}{const};
\};
\end{DoxyCode}


See \hyperlink{namespaceSpacy_a168383be933a8316169c145f5e419604_IndefiniteLinearSolverAnchor}{\+:\+:Spacy\+:\+:Indefinite\+Linear\+Solver}. \hypertarget{group__ConceptGroup_gaf0e18e41c434cfceb77ccb8e785a8055_gaf0e18e41c434cfceb77ccb8e785a8055}{}\index{Concepts@{Concepts}!Linear\+Operator\+Concept@{Linear\+Operator\+Concept}}
\index{Linear\+Operator\+Concept@{Linear\+Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Linear\+Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Linear\+Operator\+Concept} = typedef boost\+::mpl\+::vector$<$ Operator\+Concept , Vector\+Concept , has\+\_\+solver$<$boost\+::type\+\_\+erasure\+::any$<$Linear\+Solver\+Concept$>$(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_gaf0e18e41c434cfceb77ccb8e785a8055_gaf0e18e41c434cfceb77ccb8e785a8055}


Concept defining linear operators. 

\label{group__ConceptGroup_gaf0e18e41c434cfceb77ccb8e785a8055_LinearOperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_gaf0e18e41c434cfceb77ccb8e785a8055_LinearOperatorConceptAnchor}{}%
The minimal signature of a linear operator is\+: 
\begin{DoxyCode}
\textcolor{comment}{// My linear operator A: X->Y.}
\textcolor{keyword}{class }MyLinearOperator
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor.}
  MyLinearOperator(\textcolor{keyword}{const} MyLinearOperator&);

  \textcolor{comment}{// Move constructor.}
  MyLinearOperator(MyLinearOperator&&);

  \textcolor{comment}{// Compute A(x).}
  \hyperlink{classSpacy_1_1Vector}{::Spacy::Vector} operator()(const ::Spacy::Vector& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Access solver for the computation of A^-1.}
  \hyperlink{namespaceSpacy_a7d5cd1c6fb9dd85aa345b536caf30bba_a7d5cd1c6fb9dd85aa345b536caf30bba}{::Spacy::LinearSolver} solver() \textcolor{keyword}{const};

  \textcolor{comment}{// Access domain space.}
  \textcolor{keyword}{const} VectorSpace& domain() \textcolor{keyword}{const};

  \textcolor{comment}{// Access range space.}
  \textcolor{keyword}{const} VectorSpace& range() \textcolor{keyword}{const};
\};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_ga584f7b9d82a844302ba0d77c3a1b6640_LinearOperatorAnchor}{\+:\+:Spacy\+:\+:Linear\+Operator}. \hypertarget{group__ConceptGroup_gac7d6a94c7131c8613e2ab26fddeb50bd_gac7d6a94c7131c8613e2ab26fddeb50bd}{}\index{Concepts@{Concepts}!Linear\+Solver\+Concept@{Linear\+Solver\+Concept}}
\index{Linear\+Solver\+Concept@{Linear\+Solver\+Concept}!Concepts@{Concepts}}
\subsubsection[{Linear\+Solver\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Linear\+Solver\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::callable$<$Vector(const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_gac7d6a94c7131c8613e2ab26fddeb50bd_gac7d6a94c7131c8613e2ab26fddeb50bd}


Concept for linear solver implementations. Same as \hyperlink{group__ConceptGroup_gadec0c664abaacc2065dadd8b11cc8d30_CallableOperatorConceptAnchor}{Callable\+Operator\+Concept}. 

\label{group__ConceptGroup_gac7d6a94c7131c8613e2ab26fddeb50bd_LinearSolverConceptAnchor}%
\hypertarget{group__ConceptGroup_gac7d6a94c7131c8613e2ab26fddeb50bd_LinearSolverConceptAnchor}{}%
The minimal signature of a linear solver is\+: 
\begin{DoxyCode}
\textcolor{comment}{// My linear solver representing A^-1.}
\textcolor{keyword}{class }MyLinearSolver
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor.}
  MyLinearSolver(\textcolor{keyword}{const} MyLinearSolver&);

  \textcolor{comment}{// Move constructor.}
  MyLinearSolver(MyLinearSolver&&);

  \textcolor{comment}{// Compute A^-1(x).}
  \hyperlink{classSpacy_1_1Vector}{::Spacy::Vector} operator()(const ::Spacy::Vector& x) \textcolor{keyword}{const};
\};
\end{DoxyCode}


See \hyperlink{namespaceSpacy_a7d5cd1c6fb9dd85aa345b536caf30bba_LinearSolverAnchor}{\+:\+:Spacy\+:\+:Linear\+Solver}, \hyperlink{group__ConceptGroup_gadec0c664abaacc2065dadd8b11cc8d30_CallableOperatorConceptAnchor}{Callable\+Operator\+Concept} \hypertarget{group__ConceptGroup_ga6b5c97b0e58318ef98c43a9b8a7dae08_ga6b5c97b0e58318ef98c43a9b8a7dae08}{}\index{Concepts@{Concepts}!My\+Error\+Estimator\+Concept@{My\+Error\+Estimator\+Concept}}
\index{My\+Error\+Estimator\+Concept@{My\+Error\+Estimator\+Concept}!Concepts@{Concepts}}
\subsubsection[{My\+Error\+Estimator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+My\+Error\+Estimator\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::callable$<$double(const Vector\&, const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+refine$<$void()$>$ $>$}\label{group__ConceptGroup_ga6b5c97b0e58318ef98c43a9b8a7dae08_ga6b5c97b0e58318ef98c43a9b8a7dae08}


Concept for time integrators. 

\label{group__ConceptGroup_ga6b5c97b0e58318ef98c43a9b8a7dae08_ErrorEstimatorConceptAnchor}%
\hypertarget{group__ConceptGroup_ga6b5c97b0e58318ef98c43a9b8a7dae08_ErrorEstimatorConceptAnchor}{}%
The minimal signature of an error estimator is\+: 
\begin{DoxyCode}
\textcolor{comment}{// My error estimator.}
\textcolor{keyword}{class }MyErrorEstimator
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor.}
  MyErrorEstimator(\textcolor{keyword}{const} MyErrorEstimator&);

  \textcolor{comment}{// Move constructor.}
  MyErrorEstimator(MyErrorEstimator&&);

  \textcolor{comment}{// Compute error estimate.}
  \textcolor{keywordtype}{double} operator()(const ::Spacy::Vector& x, const ::Spacy::Vector& dx) \textcolor{keyword}{const};

  \textcolor{comment}{// Refine grid.}
  \textcolor{keywordtype}{void} refine();
\};
\end{DoxyCode}


See \+:\+:Spacy\+:\+:My\+Error\+Estimator. \hypertarget{group__ConceptGroup_ga8b6032c46f6e31840a2c956c6360549b_ga8b6032c46f6e31840a2c956c6360549b}{}\index{Concepts@{Concepts}!Norm\+Concept@{Norm\+Concept}}
\index{Norm\+Concept@{Norm\+Concept}!Concepts@{Concepts}}
\subsubsection[{Norm\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Norm\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::callable$<$Real(const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga8b6032c46f6e31840a2c956c6360549b_ga8b6032c46f6e31840a2c956c6360549b}


Concept for norm implementations. 

\label{group__ConceptGroup_ga8b6032c46f6e31840a2c956c6360549b_NormConceptAnchor}%
\hypertarget{group__ConceptGroup_ga8b6032c46f6e31840a2c956c6360549b_NormConceptAnchor}{}%
The minimal signature of a norm is\+: 
\begin{DoxyCode}
\textcolor{comment}{// My norm.}
\textcolor{keyword}{class }MyNorm
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor.}
  MyNorm(\textcolor{keyword}{const} MyNorm&);

  \textcolor{comment}{// Move constructor.}
  MyNorm(MyNorm&&);

  \textcolor{comment}{// Compute ||x||.}
  Real operator()(const ::Spacy::Vector& x) \textcolor{keyword}{const};
\};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_gaf4f33b11d657c48566d961a013c92bd1_NormAnchor}{\+:\+:Spacy\+:\+:Norm}. \hypertarget{group__ConceptGroup_ga7d984281b647a6d8e4c0a7ea5faeb90e_ga7d984281b647a6d8e4c0a7ea5faeb90e}{}\index{Concepts@{Concepts}!Operator\+Concept@{Operator\+Concept}}
\index{Operator\+Concept@{Operator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Operator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Operator\+Concept} = typedef boost\+::mpl\+::vector$<$ Callable\+Operator\+Concept , has\+\_\+domain$<$const Vector\+Space\&(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+range$<$const Vector\+Space\&(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga7d984281b647a6d8e4c0a7ea5faeb90e_ga7d984281b647a6d8e4c0a7ea5faeb90e}


Concept defining general operators. 

\label{group__ConceptGroup_ga7d984281b647a6d8e4c0a7ea5faeb90e_OperatorConceptAnchor}%
\hypertarget{group__ConceptGroup_ga7d984281b647a6d8e4c0a7ea5faeb90e_OperatorConceptAnchor}{}%
The minimal signature of an operator is\+: 
\begin{DoxyCode}
\textcolor{comment}{// My operator A: X->Y.}
\textcolor{keyword}{class }MyOperator
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor.}
  MyOperator(\textcolor{keyword}{const} MyOperator&);

  \textcolor{comment}{// Move constructor.}
  MyOperator(MyOperator&&);

  \textcolor{comment}{// Compute A(x).}
  \hyperlink{classSpacy_1_1Vector}{::Spacy::Vector} operator()(const ::Spacy::Vector& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Access domain space.}
  \textcolor{keyword}{const} VectorSpace& domain() \textcolor{keyword}{const};

  \textcolor{comment}{// Access range space.}
  \textcolor{keyword}{const} VectorSpace& range() \textcolor{keyword}{const};
\};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_ga3f89622eba80cf840b2a7102f1303455_OperatorAnchor}{\+:\+:Spacy\+:\+:Operator}. \hypertarget{group__ConceptGroup_ga1308724cda3078f228fb05c29556805d_ga1308724cda3078f228fb05c29556805d}{}\index{Concepts@{Concepts}!Scalar\+Product\+Concept@{Scalar\+Product\+Concept}}
\index{Scalar\+Product\+Concept@{Scalar\+Product\+Concept}!Concepts@{Concepts}}
\subsubsection[{Scalar\+Product\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Scalar\+Product\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::callable$<$Real(const Vector\&, const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga1308724cda3078f228fb05c29556805d_ga1308724cda3078f228fb05c29556805d}


Concept for scalar products. 

\label{group__ConceptGroup_ga1308724cda3078f228fb05c29556805d_ScalarProductConceptAnchor}%
\hypertarget{group__ConceptGroup_ga1308724cda3078f228fb05c29556805d_ScalarProductConceptAnchor}{}%
The minimal signature of a scalar product is\+: 
\begin{DoxyCode}
\textcolor{comment}{// My scalar product.}
\textcolor{keyword}{class }MyScalarProduct
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor.}
  MyScalarProduct(\textcolor{keyword}{const} MyScalarProduct&);

  \textcolor{comment}{// Move constructor.}
  MyScalarProduct(MyScalarProduct&&);

  \textcolor{comment}{// Compute (x,y).}
  Real operator()(const ::Spacy::Vector& x, const ::Spacy::Vector& y) \textcolor{keyword}{const};
\};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_ga9fe0b4de20da1ab1ca3d04a0f96343e1_ScalarProductAnchor}{\+:\+:Spacy\+:\+:Scalar\+Product}. \hypertarget{group__ConceptGroup_ga45ecfe57ffb996aa97c9ff89a647f095_ga45ecfe57ffb996aa97c9ff89a647f095}{}\index{Concepts@{Concepts}!Time\+Integrator\+Concept@{Time\+Integrator\+Concept}}
\index{Time\+Integrator\+Concept@{Time\+Integrator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Time\+Integrator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Time\+Integrator\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::callable$<$Vector(double, const Vector\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+set\+Time\+Step$<$void(double)$>$ $>$}\label{group__ConceptGroup_ga45ecfe57ffb996aa97c9ff89a647f095_ga45ecfe57ffb996aa97c9ff89a647f095}


Concept for time integrators. 

\label{group__ConceptGroup_ga45ecfe57ffb996aa97c9ff89a647f095_TimeIntegratorConceptAnchor}%
\hypertarget{group__ConceptGroup_ga45ecfe57ffb996aa97c9ff89a647f095_TimeIntegratorConceptAnchor}{}%
The minimal signature of a time integrator is\+: 
\begin{DoxyCode}
\textcolor{comment}{// My scalar product.}
\textcolor{keyword}{class }MyTimeIntegrator
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor.}
  MyTimeIntegrator(\textcolor{keyword}{const} MyTimeIntegrator&);

  \textcolor{comment}{// Move constructor.}
  MyTimeIntegrator(MyTimeIntegrator&&);

  \textcolor{comment}{// Compute (x,y).}
  Vector operator()(\textcolor{keywordtype}{double} t, const ::Spacy::Vector& x) \textcolor{keyword}{const};

  \textcolor{comment}{// Set time step.}
  \textcolor{keywordtype}{void} setTimeStep(\textcolor{keywordtype}{double} dt);
\};
\end{DoxyCode}


See \+:\+:Spacy\+:\+:Time\+Integrator. \hypertarget{group__ConceptGroup_gad6958389d1fa2758a8a64a0a24c36004_gad6958389d1fa2758a8a64a0a24c36004}{}\index{Concepts@{Concepts}!Vector\+Concept@{Vector\+Concept}}
\index{Vector\+Concept@{Vector\+Concept}!Concepts@{Concepts}}
\subsubsection[{Vector\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Vector\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::assignable$<$$>$ , boost\+::type\+\_\+erasure\+::multiply\+\_\+assignable$<$ boost\+::type\+\_\+erasure\+::\+\_\+self , double $>$ , boost\+::type\+\_\+erasure\+::add\+\_\+assignable$<$$>$ , boost\+::type\+\_\+erasure\+::subtract\+\_\+assignable$<$$>$ , boost\+::type\+\_\+erasure\+::negatable$<$$>$ , boost\+::type\+\_\+erasure\+::equality\+\_\+comparable$<$$>$ , boost\+::type\+\_\+erasure\+::callable$<$Vector(const boost\+::type\+\_\+erasure\+::\+\_\+self\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+space$<$const Vector\+Space$\ast$(), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ , has\+\_\+to\+File$<$void(const std\+::string\&), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_gad6958389d1fa2758a8a64a0a24c36004_gad6958389d1fa2758a8a64a0a24c36004}


Concept for vector implementations. 

\label{group__ConceptGroup_gad6958389d1fa2758a8a64a0a24c36004_VectorConceptAnchor}%
\hypertarget{group__ConceptGroup_gad6958389d1fa2758a8a64a0a24c36004_VectorConceptAnchor}{}%
The minimal signature of a vector is\+: 
\begin{DoxyCode}
\textcolor{comment}{// My vector.}
\textcolor{keyword}{class }MyVector
\{
\textcolor{keyword}{public}:
  \textcolor{comment}{// Copy constructor.}
  MyVector(\textcolor{keyword}{const} MyVector&);

  \textcolor{comment}{// Move constructor.}
  MyVector(MyVector&&);

  \textcolor{comment}{// Copy assignable x=y.}
  MyVector& operator=(\textcolor{keyword}{const} MyVector& y);

  \textcolor{comment}{// In-place summation x+=y.}
  MyVector& operator+=(\textcolor{keyword}{const} MyVector& y);

  \textcolor{comment}{// In-place subtraction x-=y.}
  MyVector& operator-=(\textcolor{keyword}{const} MyVector& y);

  \textcolor{comment}{// In-place multiplication x*=a.}
  MyVector& operator*=(\textcolor{keywordtype}{double} a);

  \textcolor{comment}{// Negation -y.}
  MyVector \hyperlink{namespaceSpacy_a8bc98f51c7beab86185bf97a29b36395}{operator-}(\textcolor{keyword}{const} MyVector& y);

  \textcolor{comment}{// Equality comparison x==y.}
  \textcolor{keywordtype}{bool} \hyperlink{namespaceSpacy_aef4930427aac4c8089b4c43b1c97cf25}{operator==}(\textcolor{keyword}{const} MyVector& y);

  \textcolor{comment}{// Apply as dual element x(y).}
  Vector operator()(\textcolor{keyword}{const} MyVector& y);

  \textcolor{comment}{// Access pointer to underlying function space.}
  \textcolor{keyword}{const} VectorSpace* space() \textcolor{keyword}{const};
\};
\end{DoxyCode}


See \hyperlink{group__SpacyGroup_gafc144d2730ef87a67e54f8cd750b1f54_VectorAnchor}{\+:\+:Spacy\+:\+:Vector}. \hypertarget{group__ConceptGroup_ga3064301642b7c66b1b08f88a12a04645_ga3064301642b7c66b1b08f88a12a04645}{}\index{Concepts@{Concepts}!Vector\+Creator\+Concept@{Vector\+Creator\+Concept}}
\index{Vector\+Creator\+Concept@{Vector\+Creator\+Concept}!Concepts@{Concepts}}
\subsubsection[{Vector\+Creator\+Concept}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Spacy\+::\+Concepts\+::\+Vector\+Creator\+Concept} = typedef boost\+::mpl\+::vector$<$ Concept\+Base , boost\+::type\+\_\+erasure\+::callable$<$boost\+::type\+\_\+erasure\+::any$<$Vector\+Concept$>$(const Vector\+Space$\ast$), const boost\+::type\+\_\+erasure\+::\+\_\+self$>$ $>$}\label{group__ConceptGroup_ga3064301642b7c66b1b08f88a12a04645_ga3064301642b7c66b1b08f88a12a04645}


\hyperlink{classSpacy_1_1Vector}{Vector} creator concept. 

\label{group__ConceptGroup_ga3064301642b7c66b1b08f88a12a04645_VectorCreatorConceptAnchor}%
\hypertarget{group__ConceptGroup_ga3064301642b7c66b1b08f88a12a04645_VectorCreatorConceptAnchor}{}%
\begin{DoxySeeAlso}{See also}
\hyperlink{classSpacy_1_1VectorSpace}{Vector\+Space}, \hyperlink{group__SpacyGroup_ga1f5316487c031a478247206764bb2efb_VectorCreatorAnchor}{Vector\+Creator}. 
\end{DoxySeeAlso}
